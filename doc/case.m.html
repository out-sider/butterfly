<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>butterfly.case API documentation</title>
    <meta name="description" content="Butterfly OpenFOAM Case." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

  <!-- highlight.js for highlighting source code. -->
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>

  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 0.9em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    margin-left: 25%;
    max-width: 90%;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    position: fixed;
    height: 100%;
    width: 25%;
    float: left;
    padding: 30px;
    overflow-x: hidden;
    overflow-y: auto;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }

  .desc {
    white-space: pre-wrap;
  }

  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
        position: inherit;
        float: none;
        width: auto;
    }
    #content {
      width: 95%;
      margin-left: auto;
      border-left: none;
      padding: 30px;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#butterfly.case.Case">Case</a></span>
        
          
  <ul>
    <li class="mono"><a href="#butterfly.case.Case.__init__">__init__</a></li>
    <li class="mono"><a href="#butterfly.case.Case.ToString">ToString</a></li>
    <li class="mono"><a href="#butterfly.case.Case.addFoamFile">addFoamFile</a></li>
    <li class="mono"><a href="#butterfly.case.Case.addFoamFiles">addFoamFiles</a></li>
    <li class="mono"><a href="#butterfly.case.Case.addRefinementRegion">addRefinementRegion</a></li>
    <li class="mono"><a href="#butterfly.case.Case.addRefinementRegions">addRefinementRegions</a></li>
    <li class="mono"><a href="#butterfly.case.Case.blockMesh">blockMesh</a></li>
    <li class="mono"><a href="#butterfly.case.Case.calculateMeshOrthogonality">calculateMeshOrthogonality</a></li>
    <li class="mono"><a href="#butterfly.case.Case.checkMesh">checkMesh</a></li>
    <li class="mono"><a href="#butterfly.case.Case.command">command</a></li>
    <li class="mono"><a href="#butterfly.case.Case.copySnappyHexMesh">copySnappyHexMesh</a></li>
    <li class="mono"><a href="#butterfly.case.Case.duplicate">duplicate</a></li>
    <li class="mono"><a href="#butterfly.case.Case.fromBFGeometries">fromBFGeometries</a></li>
    <li class="mono"><a href="#butterfly.case.Case.fromFolder">fromFolder</a></li>
    <li class="mono"><a href="#butterfly.case.Case.fromWindTunnel">fromWindTunnel</a></li>
    <li class="mono"><a href="#butterfly.case.Case.getFoamFileByName">getFoamFileByName</a></li>
    <li class="mono"><a href="#butterfly.case.Case.getFoamFilesFromLocation">getFoamFilesFromLocation</a></li>
    <li class="mono"><a href="#butterfly.case.Case.getResultFolders">getResultFolders</a></li>
    <li class="mono"><a href="#butterfly.case.Case.getSnappyHexMeshFolders">getSnappyHexMeshFolders</a></li>
    <li class="mono"><a href="#butterfly.case.Case.loadMesh">loadMesh</a></li>
    <li class="mono"><a href="#butterfly.case.Case.loadPoints">loadPoints</a></li>
    <li class="mono"><a href="#butterfly.case.Case.loadProbeValues">loadProbeValues</a></li>
    <li class="mono"><a href="#butterfly.case.Case.loadProbes">loadProbes</a></li>
    <li class="mono"><a href="#butterfly.case.Case.purge">purge</a></li>
    <li class="mono"><a href="#butterfly.case.Case.removePolyMeshContent">removePolyMeshContent</a></li>
    <li class="mono"><a href="#butterfly.case.Case.removePostProcessingFolder">removePostProcessingFolder</a></li>
    <li class="mono"><a href="#butterfly.case.Case.removeProcessorFolders">removeProcessorFolders</a></li>
    <li class="mono"><a href="#butterfly.case.Case.removeResultFolders">removeResultFolders</a></li>
    <li class="mono"><a href="#butterfly.case.Case.removeSnappyHexMeshFolders">removeSnappyHexMeshFolders</a></li>
    <li class="mono"><a href="#butterfly.case.Case.renameSnappyHexMeshFolders">renameSnappyHexMeshFolders</a></li>
    <li class="mono"><a href="#butterfly.case.Case.sample">sample</a></li>
    <li class="mono"><a href="#butterfly.case.Case.save">save</a></li>
    <li class="mono"><a href="#butterfly.case.Case.snappyHexMesh">snappyHexMesh</a></li>
    <li class="mono"><a href="#butterfly.case.Case.surfaceFeatureExtract">surfaceFeatureExtract</a></li>
    <li class="mono"><a href="#butterfly.case.Case.updateBCInZeroFolder">updateBCInZeroFolder</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">butterfly.case</span> module</h1>
  <p>Butterfly OpenFOAM Case.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case" class="source">
    <pre><code>﻿"""Butterfly OpenFOAM Case."""
import os
import re  # to check input names
from shutil import rmtree  # to remove case folders if needed
from distutils.dir_util import copy_tree  # to copy sHM meshes over to tri
from collections import namedtuple
from copy import deepcopy
from itertools import izip

from .version import Version
from .utilities import loadCaseFiles, loadProbeValuesFromFolder, \
    loadProbesFromPostProcessingFile, loadProbesAndValuesFromSampleFile
from .geometry import bfGeometryFromStlFile, calculateMinMaxFromBFGeometries
from .refinementRegion import refinementRegionsFromStlFile
from .meshingparameters import MeshingParameters
from .fields import Field

#
from .foamfile import FoamFile

# constant folder objects
from .turbulenceProperties import TurbulenceProperties
from .RASProperties import RASProperties
from .transportProperties import TransportProperties
from .g import G

# 0 folder objects
from .U import U
from .k import K
from .p import P
from .nut import Nut
from .epsilon import Epsilon
from .T import T
from .alphat import Alphat
from .p_rgh import P_rgh
from .conditions import ABLConditions, InitialConditions

# # system folder objects
from .blockMeshDict import BlockMeshDict
from .controlDict import ControlDict
from .snappyHexMeshDict import SnappyHexMeshDict
from .fvSchemes import FvSchemes
from .fvSolution import FvSolution
from .functions import Probes
from .decomposeParDict import DecomposeParDict
from .sampleDict import SampleDict

from .runmanager import RunManager


class Case(object):
    """OpenFOAM Case.

    Attributes:
        name: Case name as a string with no whitespace.
        foamfiles: Collection of FoamFile objects (dictionaries) for this case.
        geometries: Collection of geometry-like objects. Geometries should have
            a name and toStlString method. The information related to boundary
            condition should already be included in related foamfiles. If you
            want to initiate the class form a folder or a number of BFGeometries
            use fromFolder, and fromBFGeometries classmethods.
    """

    SUBFOLDERS = ('0', 'constant', 'constant\\polyMesh',
                  'constant\\triSurface', 'system', 'log')

    # minimum list of files to be able to run blockMesh and snappyHexMesh
    MINFOAMFILES = ('fvSchemes', 'fvSolution', 'controlDict', 'blockMeshDict',
                    'snappyHexMeshDict')

    def __init__(self, name, foamfiles, geometries):
        """Init case."""
        # original name is a variable to address the current limitation to change
        # the name of stl file in snappyHexMeshDict. It will be removed once the
        # limitation is addressed. The value wil be assigned in classmethod fromFile
        self.__originalName = None

        self.projectName = name
        self.__version = float(Version.OFVer)
        self.decomposeParDict = None

        # optional input for changing working directory
        # should not be used on OpenFOAM on Windows
        self.workingDir = os.path.join(os.path.expanduser('~'), 'butterfly')

        # set foamfiles dynamically. This is flexible but makes documentation
        # tricky. also autocomplete won't work for this cases.
        self.__foamfiles = []
        self.addFoamFiles(foamfiles)

        # set butterfly geometries
        self.__geometries = self.__checkInputGeometries(geometries)

        # place holder for refinment regions
        # use .addRefinementRegions to add regions to case
        self.__refinementRegions = []
        self.runmanager = RunManager(self.projectName)

    @classmethod
    def fromFolder(cls, path, name=None, convertFromMeters=1):
        """Create a Butterfly case from a case folder.

        Args:
            path: Full path to case folder.
            name: An optional new name for this case.
            convertFromMeters: A number to be multiplied to stl file vertices
                to be converted to the new units if not meters. This value will
                be the inverse of convertToMeters.
        """
        # collect foam files
        __originalName = os.path.split(path)[-1]
        if not name:
            name = __originalName

        _files = loadCaseFiles(path, fullpath=True)

        # convert files to butterfly objects
        ff = []
        for f in (_files.zero, _files.constant, _files.system):
            for p in f:
                if not p:
                    continue
                try:
                    ff.append(cls.__createFoamfileFromFile(p, 1.0 / convertFromMeters))
                    print('Imported {} from case.'.format(p))
                except Exception as e:
                    print('Failed to import {}:\n\t{}'.format(p, e))
        sHMD = cls.__getFoamFileByName('snappyHexMeshDict', ff)

        if sHMD:
            sHMD.projectName = name

            stlfiles = tuple(f for f in _files.stl if f.lower().endswith('.stl'))
            bfGeometries = tuple(
                geo for f in stlfiles
                for geo in bfGeometryFromStlFile(f, convertFromMeters)
                if os.path.split(f)[-1][:-4] in sHMD.stlFileNames)

        else:
            bfGeometries = []

        _case = cls(name, ff, bfGeometries)

        # update each field of boundary condition for geometries
        for ff in _case.getFoamFilesFromLocation('0'):
            for geo in _case.geometries:
                try:
                    f = ff.getBoundaryField(geo.name)
                except AttributeError as e:
                    if not geo.name.endswith('Conditions'):
                        print(str(e))
                else:
                    # set boundary condition for the field
                    if not f:
                        setattr(geo.boundaryCondition, ff.name, None)
                    else:
                        setattr(geo.boundaryCondition, ff.name, Field.fromDict(f))

        if sHMD:
            refinementRegions = tuple(
                ref for f in _files.stl
                if os.path.split(f)[-1][:-4] in sHMD.refinementRegionNames
                for ref in refinementRegionsFromStlFile(
                    f, sHMD.refinementRegionMode(os.path.split(f)[-1][:-4]))
            )

            _case.addRefinementRegions(refinementRegions)

        # original name is a variable to address the current limitation to change
        # the name of stl file in snappyHexMeshDict. It will be removed once the
        # limitation is addressed.
        _case.__originalName = __originalName

        return _case

    @classmethod
    def fromBFGeometries(cls, name, geometries, blockMeshDict=None,
                         meshingParameters=None, make2dParameters=None,
                         convertToMeters=1):
        """Create a case from Butterfly geometries.

        foamFiles/dictionaries will be generated based on boundary condition of
        geometries. fvSolution and fvSchemes will be set to default can can be
        overwritten once a Solution is created from a Case and a Recipe. You can
        overwrite them through the recipe.

        Args:
            name: Case name as a string with no whitespace.
            geometries: Collection of BFGeometries. FoamFiles/dictionaries will
                be generated based on boundary condition of geometries.
            blockMeshDict: Optional input for blockMeshDict. If blockMeshDict is
                not provided, it will be calculated from geometries in XY
                direction and boundary condition for faces will be set to
                BoundingBoxBoundaryCondition. Use BlockMeshDict to create the
                blockMeshDict if your case is not aligned to XY direction or you
                need to assign different boundary condition to geometries.
            meshingParameters: Optional input for MeshingParameters.
            make2dParameters: Optional input for make2dParameters to make a 2d
                case.
        """
        geometries = cls.__checkInputGeometries(geometries)

        # update meshingParameters
        if not meshingParameters:
            meshingParameters = MeshingParameters()

        # create foam files
        if not blockMeshDict:
            minPt, maxPt = calculateMinMaxFromBFGeometries(geometries)
            blockMeshDict = BlockMeshDict.fromMinMax(minPt, maxPt, convertToMeters)

        if make2dParameters:
            # create the 2D blockMeshDict
            blockMeshDict.make2d(
                make2dParameters.origin, make2dParameters.normal,
                make2dParameters.width)

        blockMeshDict.updateMeshingParameters(meshingParameters)

        # set the locationInMesh for snappyHexMeshDict
        if make2dParameters:
            meshingParameters.locationInMesh = make2dParameters.origin
        if not meshingParameters.locationInMesh:
            meshingParameters.locationInMesh = blockMeshDict.center

        # rename name for snappyHexMeshDict and stl file if starts with a digit
        normname = '_{}'.format(name) if name[0].isdigit() else name
        snappyHexMeshDict = SnappyHexMeshDict.fromBFGeometries(
            normname, geometries, meshingParameters,
            convertToMeters=blockMeshDict.convertToMeters)

        # constant folder
        if float(Version.OFVer) < 3:
            turbulenceProperties = RASProperties()
        else:
            turbulenceProperties = TurbulenceProperties()
        transportProperties = TransportProperties()
        g = G()

        # 0 floder
        try:
            _geometries = geometries + blockMeshDict.geometry
        except TypeError:
            _geometries = tuple(geometries) + blockMeshDict.geometry

        u = U.fromBFGeometries(_geometries)
        p = P.fromBFGeometries(_geometries)
        k = K.fromBFGeometries(_geometries)
        epsilon = Epsilon.fromBFGeometries(_geometries)
        nut = Nut.fromBFGeometries(_geometries)
        t = T.fromBFGeometries(_geometries)
        alphat = Alphat.fromBFGeometries(_geometries)
        p_rgh = P_rgh.fromBFGeometries(_geometries)

        # system folder
        fvSchemes = FvSchemes()
        fvSolution = FvSolution()
        controlDict = ControlDict()
        probes = Probes()

        foamFiles = (blockMeshDict, snappyHexMeshDict, turbulenceProperties,
                     transportProperties, g, u, p, k, epsilon, nut, t, alphat,
                     p_rgh, fvSchemes, fvSolution, controlDict, probes)

        # create case
        _cls = cls(name, foamFiles, geometries)
        _cls.__originalName = normname
        return _cls

    @classmethod
    def fromWindTunnel(cls, windTunnel, make2dParameters=None):
        """Create case from wind tunnel."""
        _case = cls.fromBFGeometries(
            windTunnel.name, windTunnel.testGeomtries, windTunnel.blockMeshDict,
            windTunnel.meshingParameters, make2dParameters)

        initialConditions = InitialConditions(
            Uref=windTunnel.flowSpeed, Zref=windTunnel.Zref, z0=windTunnel.z0)

        ablConditions = ABLConditions.fromWindTunnel(windTunnel)

        # add initialConditions and ABLConditions to _case
        _case.addFoamFiles((initialConditions, ablConditions))

        # include condition files in 0 folder files
        _case.U.updateValues({'#include': '"initialConditions"',
                              'internalField': 'uniform $flowVelocity'},
                             mute=True)
        _case.p.updateValues({'#include': '"initialConditions"',
                              'internalField': 'uniform $pressure'},
                             mute=True)
        _case.k.updateValues({'#include': '"initialConditions"',
                              'internalField': 'uniform $turbulentKE'},
                             mute=True)
        _case.epsilon.updateValues({'#include': '"initialConditions"',
                                    'internalField': 'uniform $turbulentEpsilon'},
                                   mute=True)

        if windTunnel.refinementRegions:
            for region in windTunnel.refinementRegions:
                _case.addRefinementRegion(region)

        return _case

    @property
    def isCase(self):
        """return True."""
        return True

    @property
    def projectName(self):
        """Project name."""
        return self.__projectName

    @projectName.setter
    def projectName(self, name):
        assert re.match("^[a-zA-Z0-9_]*$", name), \
            'Invalid project name: "{}".\n' \
            'Do not use whitespace or special charecters.'.format(name)
        self.__projectName = name

    @property
    def geometries(self):
        """Butterfly geometries."""
        if hasattr(self, 'blockMeshDict'):
            try:
                return self.__geometries + self.blockMeshDict.geometry
            except TypeError:
                return tuple(self.__geometries) + self.blockMeshDict.geometry

        return self.__geometries

    @property
    def workingDir(self):
        """Change default working directory.

        Do not change the working dir if you are using OpenFOAM for Windows
        to run the analysis.
        """
        return self.__workingDir

    @workingDir.setter
    def workingDir(self, p):
        self.__workingDir = os.path.normpath(p)

    @property
    def projectDir(self):
        """Get project directory."""
        return os.path.join(self.workingDir, self.projectName)

    @property
    def zeroFolder(self):
        """Folder 0 fullpath."""
        return os.path.join(self.projectDir, '0')

    @property
    def constantFolder(self):
        """constant folder fullpath."""
        return os.path.join(self.projectDir, 'constant')

    @property
    def systemFolder(self):
        """system folder fullpath."""
        return os.path.join(self.projectDir, 'system')

    @property
    def logFolder(self):
        """log folder fullpath."""
        return os.path.join(self.projectDir, 'log')

    @property
    def polyMeshFolder(self):
        """polyMesh folder fullpath."""
        return os.path.join(self.projectDir, 'constant\\polyMesh')

    @property
    def triSurfaceFolder(self):
        """triSurface folder fullpath."""
        return os.path.join(self.projectDir, 'constant\\triSurface')

    @property
    def postProcessingFolder(self):
        """postProcessing folder fullpath."""
        return os.path.join(self.projectDir, 'postProcessing')

    @property
    def probesFolder(self):
        """Fullpath to probes folder."""
        return os.path.join(self.postProcessingFolder, 'probes')

    @property
    def foamFiles(self):
        """Get all the foamFiles."""
        return tuple(f for f in self.__foamfiles)

    @property
    def refinementRegions(self):
        """Get refinement regions."""
        return self.__refinementRegions

    @property
    def isPolyMeshSnappyHexMesh(self):
        """Check if the mesh in polyMesh folder is snappyHexMesh."""
        return len(os.listdir(self.polyMeshFolder)) > 5

    @property
    def probes(self):
        """Get and set Probes."""
        return self.__probes

    @probes.setter
    def probes(self, inp):
        if not inp:
            return

        assert hasattr(inp, 'probeLocations'), \
            "Expected Probes not {}".format(type(inp))

        self.__probes = inp
        if self.probes.probesCount > 0:
            # include probes in controlDict
            self.controlDict.include = self.probes.filename

    def getFoamFileByName(self, name):
        """Get a foamfile by name."""
        return self.__getFoamFileByName(name, self.foamFiles)

    def getSnappyHexMeshFolders(self):
        """Return sorted list of numerical folders."""
        _f = [int(name) for name in os.listdir(self.projectDir)
              if (name.isdigit() and
                  os.path.isdir(os.path.join(self.projectDir,
                                             name, 'polyMesh'))
                  )]

        _f.sort()

        return tuple(str(f) for f in _f)

    def getResultFolders(self):
        """Return sorted list of numerical folders."""
        _f = [int(name) for name in os.listdir(self.projectDir)
              if (name != '0' and name.isdigit() and
                  os.path.isdir(os.path.join(self.projectDir, name)) and
                  not os.path.isdir(os.path.join(self.projectDir, name, 'polyMesh'))
                  )]

        _f.sort()

        return tuple(str(f) for f in _f)

    def getFoamFilesFromLocation(self, location=None):
        """Get foamFiles in a specific location (0, constant, system)."""
        if not location:
            return tuple(f for f in self.__foamfiles)
        else:
            return tuple(f for f in self.__foamfiles
                         if f.location == '"{}"'.format(location))

    def addFoamFiles(self, foamfiles):
        """Add foamfiles to the Case."""
        for ff in foamfiles:
            self.addFoamFile(ff)

    def addFoamFile(self, foamfile):
        """Add a foamfile to the case."""
        if not foamfile:
            return
        assert hasattr(foamfile, 'isFoamFile'), \
            '{} is not a FoamFile'.format(foamfile)
        try:
            setattr(self, foamfile.name, foamfile)
            self.__foamfiles.append(foamfile)
        except AttributeError as e:
            raise ValueError('Failed to add {}.\n\t{}'.format(foamfile, e))

    def addRefinementRegions(self, refinementRegions):
        """Add a collections of refinement regions."""
        for refinementRegion in refinementRegions:
            self.addRefinementRegion(refinementRegion)

    def addRefinementRegion(self, refinementRegion):
        """Add a refinement region."""
        assert hasattr(refinementRegion, 'isRefinementRegion'), \
            "{} is not a refinement region.".format(refinementRegion)

        self.__refinementRegions.append(refinementRegion)
        assert hasattr(self, 'snappyHexMeshDict'), \
            'You can\'t add a refinementRegion to a case with no snappyHexMeshDict.'

        self.snappyHexMeshDict.addRefinementRegion(refinementRegion)

    def copySnappyHexMesh(self, folderNumber=None, overwrite=True):
        """Copy the results of snappyHexMesh to constant/polyMesh."""
        # pick the last numerical folder
        if folderNumber:
            _s = os.path.join(self.projectDir, str(folderNumber), 'polyMesh')
            assert os.path.isdir(_s), "Can't find {}.".format(_s)
        else:
            _folders = self.getSnappyHexMeshFolders()
            if not _folders:
                return
            _s = os.path.join(self.projectDir, _folders[-1], 'polyMesh')

        # copy files to constant/polyMesh
        if overwrite:
            self.removePolyMeshContent()

        try:
            copy_tree(_s, self.polyMeshFolder)
        except Exception as e:
            print("Failed to copy snappyHexMesh folder: {}".format(e))

    def renameSnappyHexMeshFolders(self, add=True):
        """Rename snappyHexMesh numerical folders to name.org  and vice versa.

        Args:
            add: Set to True to add .org at the end of the file. Set to False
                to rename them back to the original naming.
        """
        # find list of folders in project and collect the numbers
        if not add:
            _folders = (name for name in os.listdir(self.projectDir)
                        if (name.endswith('.org') and
                            os.path.isdir(os.path.join(self.projectDir, name,
                                                       'polyMesh'))))

            for f in _folders:
                os.rename(os.path.join(self.projectDir, f),
                          os.path.join(self.projectDir, f.replace('.org', '')))
        else:
            _folders = self.getSnappyHexMeshFolders()

            # rename them starting from 1
            for f in _folders:
                try:
                    os.rename(os.path.join(self.projectDir, f),
                              os.path.join(self.projectDir, '%s.org' % f))
                except Exception as e:
                    raise Exception('Failed to rename snappyHexMesh folders: {}'
                                    .format(e))

    def removeSnappyHexMeshFolders(self):
        """Remove snappyHexMesh numerical folders.

        Use this to clean the folder.
        """
        self.renameSnappyHexMeshFolders(add=False)
        _folders = self.getSnappyHexMeshFolders()

        for f in _folders:
            try:
                rmtree(os.path.join(self.projectDir, f))
            except Exception as e:
                print('Failed to remove {}:\n{}'.format(f, e))

    def removeResultFolders(self):
        """Remove results folder."""
        _folders = self.getResultFolders()
        for _f in _folders:
            try:
                rmtree(os.path.join(self.projectDir, _f))
            except Exception as e:
                print('Failed to remove {}:\n{}'.format(_f, e))

    def removePostProcessingFolder(self):
        """Remove post postProcessing folder."""
        if not os.path.isdir(self.postProcessingFolder):
            return

        try:
            rmtree(self.postProcessingFolder)
        except Exception as e:
            print('Failed to remove postProcessing folder:\n{}'.format(e))

    def removePolyMeshContent(self):
        """Remove files inside polyMesh folder."""
        for _f in os.listdir(self.polyMeshFolder):
            if _f != 'blockMeshDict':
                _fp = os.path.join(self.polyMeshFolder, _f)
                if os.path.isfile(_fp):
                    os.remove(_fp)
                elif os.path.isdir(_fp):
                    rmtree(_fp)

    def removeProcessorFolders(self):
        """Remove processor folders for parallel runs."""

        ff = (os.path.join(self.projectDir, d)
              for d in os.listdir(self.projectDir)
              if d.startswith('processor') and
              os.path.isdir(os.path.join(self.projectDir, d)))

        for f in ff:
            try:
                rmtree(f)
            except Exception as e:
                print('Failed to remove processor folder:\n{}'.format(e))

    def purge(self, removePolyMeshContent=True,
              removeSnappyHexMeshFolders=True,
              removeResultFolders=False,
              removePostProcessingFolder=False):
        """Purge case folder."""
        if removePolyMeshContent:
            self.removePolyMeshContent()
        if removeSnappyHexMeshFolders:
            self.removeSnappyHexMeshFolders()
        if removeResultFolders:
            self.removeResultFolders()
        if removePostProcessingFolder:
            self.removePostProcessingFolder()

    def updateBCInZeroFolder(self):
        """Update boundary conditions in files in 0 folder.

        Call this method if you have made any changes to boundary condition of
        any of the geometries after initiating the class.
        """
        raise NotImplementedError()

    def save(self, overwrite=False, minimum=True):
        """Save case to folder.

        Args:
            overwrite: If True all the current content will be overwritten
                (default: False).
            minimum: Write minimum necessary files for case. These files will
                be enough for meshing the case but not running any commands.
                Files are ('fvSchemes', 'fvSolution', 'controlDict',
                'blockMeshDict','snappyHexMeshDict'). Rest of the files will be
                created from a Solution.
        """
        # create folder and subfolders if they are not already created
        if overwrite and os.path.exists(self.projectDir):
            rmtree(self.projectDir, ignore_errors=True)

        for f in self.SUBFOLDERS:
            p = os.path.join(self.projectDir, f)
            if not os.path.exists(p):
                try:
                    os.makedirs(p)
                except Exception as e:
                    msg = 'Butterfly failed to create {}\n\t{}'.format(p, e)
                    if str(e).startswith('[Error 183]'):
                        print(msg)
                    else:
                        raise IOError(msg)

        # save foamfiles
        if minimum:
            foamFiles = (ff for ff in self.foamFiles
                         if ff.name in self.MINFOAMFILES)
        else:
            foamFiles = self.foamFiles

        for f in foamFiles:
            f.save(self.projectDir)

        # find blockMeshDict and convertToMeters so I can scale stl files to meters.
        bmds = (ff for ff in self.foamFiles if ff.name == 'blockMeshDict')
        bmd = bmds.next()
        convertToMeters = bmd.convertToMeters

        # write bfgeometries to stl file. __geometries is geometries without
        # blockMesh geometry
        stlStr = (geo.toSTL(convertToMeters) for geo in self.__geometries)
        stlName = self.__originalName or self.projectName
        with open(os.path.join(self.triSurfaceFolder,
                               '%s.stl' % stlName), 'wb') as stlf:
            stlf.writelines(stlStr)

        # write refinementRegions to stl files
        for ref in self.refinementRegions:
            ref.writeToStl(self.triSurfaceFolder, convertToMeters)

        # add .foam file
        with open(os.path.join(self.projectDir,
                               self.projectName + '.foam'), 'wb') as ffile:
            ffile.write('')

        print('{} is saved to: {}'.format(self.projectName, self.projectDir))

    def command(self, cmd, args=None, decomposeParDict=None, run=True, wait=True):
        ur"""Run an OpenFOAM command for this case.
        This method creates a log and err file under logFolder for each command.
        The output will be logged as {cmd}.log and {cmd}.err.
        Args:
            cmd: OpenFOAM command.
            args: Command arguments.
            decomposeParDict: Optional input for decomposeParDict to run analysis
                in parallel if desired.
            run: Run the command in shell.
            wait: Wait until the command is over.
        returns:
            If run is True returns a namedtuple for
                (success, error, process, logfiles, errorfiles).
                success: as a boolen.
                error: None in case of success otherwise the error message as
                    a string.
                process: Popen process.
                logfiles: List of fullpath to log files.
                errorfiles: List of fullpath to error files.
            else return a namedtuple for
                (cmd, logfiles, errorfiles)
                cmd: command lines.
                logfiles: A tuple for log files.
                errorfiles: A tuple for error files.
        """
        if not run:
            cmdlog = self.runmanager.command(cmd, args, decomposeParDict)
            return cmdlog
        else:
            log = namedtuple('log', 'success error process logfiles errorfiles')

            p, logfiles, errfiles = self.runmanager.run(cmd, args,
                                                        decomposeParDict, wait)

            logfiles = tuple(os.path.normpath(os.path.join(self.projectDir, f))
                             for f in logfiles)

            errfiles = tuple(os.path.normpath(os.path.join(self.projectDir, f))
                             for f in errfiles)

            # check error files and raise and error
            if wait:
                self.runmanager.checkFileContents(logfiles, mute=False)
                hascontent, content = self.runmanager.checkFileContents(errfiles)

                return log(not hascontent, content, p, logfiles, errfiles)
            else:
                # return a namedtuple assuming that the command is running fine.
                return log(True, None, p, logfiles, errfiles)

    def blockMesh(self, args=None, wait=True, overwrite=True,):
        """Run blockMesh.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
            overwrite: Overwrite current content of the folder.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        if overwrite:
            self.removePolyMeshContent()

        return self.command('blockMesh', args, decomposeParDict=None,
                            wait=wait)

    def surfaceFeatureExtract(self, args=None, wait=True):
        """Run surfaceFeatureExtract command.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        # create surfaceFeatureExtractDict if it's not created
        return self.command('surfaceFeatureExtract', args, decomposeParDict=None,
                            wait=wait)

    # TODO(Mostapha): Sample for multiple fields.
    # The reason we don't have it now is that I don't have the methods in place
    # for dealing with lists of lists in Grasshopper.
    def sample(self, name, points, field, wait=True):
        """Sample the results for a certain field.

        Args:
            name: A unique name for this sample.
            points: List of points as (x, y, z).
            fields: List of fields (e.g. U, p).
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(probes, values).
        """
        sd = SampleDict.fromPoints(name, points, (field,))
        sd.save(self.projectDir)

        log = self.command(
            'postProcess', args=('-func', 'sampleDict', '-latestTime'),
            decomposeParDict=None, wait=wait)

        if not log.success:
            raise Exception("Failed to sample the case:\n\t%s"
                            % log.error)

        rf = list(int(f) for f in self.getResultFolders())
        rf.sort()

        fp = tuple(os.path.join(self.postProcessingFolder, 'sampleDict', str(rf[-1]), f)
                   for f in sd.outputFilenames)

        if fp:
            res = loadProbesAndValuesFromSampleFile(fp[0])
            pts, values = izip(*(r for r in res))
            res = namedtuple('Results', 'probes values')
            return res(pts, values)

    def snappyHexMesh(self, args=None, wait=True):
        """Run snappyHexMesh.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        return self.command('snappyHexMesh', args, self.decomposeParDict,
                            wait=wait)

    def checkMesh(self, args=None, wait=True):
        """Run checkMesh.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        return self.command('checkMesh', args, self.decomposeParDict,
                            wait=wait)

    def calculateMeshOrthogonality(self, useCurrntCheckMeshLog=False):
        """Calculate max and average mesh orthogonality.

        If average values is more than 80, try to generate a better mesh.
        You can use this values to set discretization schemes.
        try case.setFvSchemes(averageOrthogonality)
        """
        if not useCurrntCheckMeshLog:
            log = self.checkMesh(args=('-latestTime',))
            assert log.success, log.error

        f = os.path.join(self.logFolder, 'checkMesh.log')
        assert os.path.isfile(f), 'Failed to find {}.'.format(f)

        with open(f, 'rb') as inf:
            results = ''.join(inf.readlines())
            maximum, average = results \
                .split('Mesh non-orthogonality Max:')[-1] \
                .split('average:')[:2]

            average = average.split('\n')[0]

        return float(maximum), float(average)

    @staticmethod
    def __getFoamFileByName(name, foamfiles):
        """Get a foamfile by name."""
        for f in foamfiles:
            if f.name == name:
                return f

    @staticmethod
    def __createFoamfileFromFile(p, convertToMeters=1):
        """Create a foamfile object from an OpenFOAM foamfile.

        Args:
            p: Fullpath to file.
        Return:
            A Butterfly foam file.
        """
        # Butterfly FoamFiles. This dictionary should be expanded.
        __foamfilescollection = {
            'turbulenceProperties': TurbulenceProperties,
            'RASProperties': RASProperties,
            'transportProperties': TransportProperties, 'g': G,
            'U': U, 'k': K, 'p': P, 'nut': Nut, 'epsilon': Epsilon, 'T': T,
            'alphat': Alphat, 'p_rgh': P_rgh, 'ABLConditions': ABLConditions,
            'initialConditions': InitialConditions,
            'blockMeshDict': BlockMeshDict, 'snappyHexMeshDict': SnappyHexMeshDict,
            'controlDict': ControlDict, 'fvSchemes': FvSchemes,
            'fvSolution': FvSolution, 'probes': Probes,
            'decomposeParDict': DecomposeParDict
        }

        name = os.path.split(p)[-1].split('.')[0]
        if name == 'blockMeshDict':
            try:
                return BlockMeshDict.fromFile(p, convertToMeters)
            except Exception as e:
                print('Failed to import {}:\n\t{}'.format(p, e))
        elif name in __foamfilescollection:
            try:
                return __foamfilescollection[name].fromFile(p)
            except Exception as e:
                print('Failed to import {}:\n\t{}'.format(p, e))
        else:
            return FoamFile.fromFile(p)

    @staticmethod
    def __checkInputGeometries(geos):
        for geo in geos:
            assert hasattr(geo, 'isBFMesh'), \
                'Expected butterfly.Mesh not {}'.format(geo)
        return geos

    def loadMesh(self):
        """Return OpenFOAM mesh as a Rhino mesh."""
        # This is a abstract property which should be implemented in subclasses
        raise NotImplementedError()

    def loadPoints(self):
        """Return OpenFOAM mesh as a Rhino mesh."""
        # This is a abstract property which should be implemented in subclasses
        raise NotImplementedError()

    def loadProbeValues(self, field):
        """Return OpenFOAM probes results for a field."""
        if self.probes.probesCount == 0:
            return ()

        if field not in self.probes.fields:
            raise ValueError("Can't find {} in {}.".format(field,
                                                           self.probes.fields))

        return loadProbeValuesFromFolder(self.probesFolder, field)

    def loadProbes(self, field):
        """Return OpenFOAM probes locations for a field."""
        if self.probes.probesCount == 0:
            return ()

        if field not in self.probes.fields:
            raise ValueError("Can't find {} in {}.".format(field,
                                                           self.probes.fields))

        return loadProbesFromPostProcessingFile(self.probesFolder, field)

    def duplicate(self):
        """Return a copy of this object."""
        return deepcopy(self)

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """OpenFOAM CASE."""
        return "OpenFOAM CASE: %s" % self.projectName
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="butterfly.case.Case" class="name">class <span class="ident">Case</span></p>
      
  
    <div class="desc"><p>OpenFOAM Case.</p>
<p>Attributes:
    name: Case name as a string with no whitespace.
    foamfiles: Collection of FoamFile objects (dictionaries) for this case.
    geometries: Collection of geometry-like objects. Geometries should have
        a name and toStlString method. The information related to boundary
        condition should already be included in related foamfiles. If you
        want to initiate the class form a folder or a number of BFGeometries
        use fromFolder, and fromBFGeometries classmethods.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case" class="source">
    <pre><code>class Case(object):
    """OpenFOAM Case.

    Attributes:
        name: Case name as a string with no whitespace.
        foamfiles: Collection of FoamFile objects (dictionaries) for this case.
        geometries: Collection of geometry-like objects. Geometries should have
            a name and toStlString method. The information related to boundary
            condition should already be included in related foamfiles. If you
            want to initiate the class form a folder or a number of BFGeometries
            use fromFolder, and fromBFGeometries classmethods.
    """

    SUBFOLDERS = ('0', 'constant', 'constant\\polyMesh',
                  'constant\\triSurface', 'system', 'log')

    # minimum list of files to be able to run blockMesh and snappyHexMesh
    MINFOAMFILES = ('fvSchemes', 'fvSolution', 'controlDict', 'blockMeshDict',
                    'snappyHexMeshDict')

    def __init__(self, name, foamfiles, geometries):
        """Init case."""
        # original name is a variable to address the current limitation to change
        # the name of stl file in snappyHexMeshDict. It will be removed once the
        # limitation is addressed. The value wil be assigned in classmethod fromFile
        self.__originalName = None

        self.projectName = name
        self.__version = float(Version.OFVer)
        self.decomposeParDict = None

        # optional input for changing working directory
        # should not be used on OpenFOAM on Windows
        self.workingDir = os.path.join(os.path.expanduser('~'), 'butterfly')

        # set foamfiles dynamically. This is flexible but makes documentation
        # tricky. also autocomplete won't work for this cases.
        self.__foamfiles = []
        self.addFoamFiles(foamfiles)

        # set butterfly geometries
        self.__geometries = self.__checkInputGeometries(geometries)

        # place holder for refinment regions
        # use .addRefinementRegions to add regions to case
        self.__refinementRegions = []
        self.runmanager = RunManager(self.projectName)

    @classmethod
    def fromFolder(cls, path, name=None, convertFromMeters=1):
        """Create a Butterfly case from a case folder.

        Args:
            path: Full path to case folder.
            name: An optional new name for this case.
            convertFromMeters: A number to be multiplied to stl file vertices
                to be converted to the new units if not meters. This value will
                be the inverse of convertToMeters.
        """
        # collect foam files
        __originalName = os.path.split(path)[-1]
        if not name:
            name = __originalName

        _files = loadCaseFiles(path, fullpath=True)

        # convert files to butterfly objects
        ff = []
        for f in (_files.zero, _files.constant, _files.system):
            for p in f:
                if not p:
                    continue
                try:
                    ff.append(cls.__createFoamfileFromFile(p, 1.0 / convertFromMeters))
                    print('Imported {} from case.'.format(p))
                except Exception as e:
                    print('Failed to import {}:\n\t{}'.format(p, e))
        sHMD = cls.__getFoamFileByName('snappyHexMeshDict', ff)

        if sHMD:
            sHMD.projectName = name

            stlfiles = tuple(f for f in _files.stl if f.lower().endswith('.stl'))
            bfGeometries = tuple(
                geo for f in stlfiles
                for geo in bfGeometryFromStlFile(f, convertFromMeters)
                if os.path.split(f)[-1][:-4] in sHMD.stlFileNames)

        else:
            bfGeometries = []

        _case = cls(name, ff, bfGeometries)

        # update each field of boundary condition for geometries
        for ff in _case.getFoamFilesFromLocation('0'):
            for geo in _case.geometries:
                try:
                    f = ff.getBoundaryField(geo.name)
                except AttributeError as e:
                    if not geo.name.endswith('Conditions'):
                        print(str(e))
                else:
                    # set boundary condition for the field
                    if not f:
                        setattr(geo.boundaryCondition, ff.name, None)
                    else:
                        setattr(geo.boundaryCondition, ff.name, Field.fromDict(f))

        if sHMD:
            refinementRegions = tuple(
                ref for f in _files.stl
                if os.path.split(f)[-1][:-4] in sHMD.refinementRegionNames
                for ref in refinementRegionsFromStlFile(
                    f, sHMD.refinementRegionMode(os.path.split(f)[-1][:-4]))
            )

            _case.addRefinementRegions(refinementRegions)

        # original name is a variable to address the current limitation to change
        # the name of stl file in snappyHexMeshDict. It will be removed once the
        # limitation is addressed.
        _case.__originalName = __originalName

        return _case

    @classmethod
    def fromBFGeometries(cls, name, geometries, blockMeshDict=None,
                         meshingParameters=None, make2dParameters=None,
                         convertToMeters=1):
        """Create a case from Butterfly geometries.

        foamFiles/dictionaries will be generated based on boundary condition of
        geometries. fvSolution and fvSchemes will be set to default can can be
        overwritten once a Solution is created from a Case and a Recipe. You can
        overwrite them through the recipe.

        Args:
            name: Case name as a string with no whitespace.
            geometries: Collection of BFGeometries. FoamFiles/dictionaries will
                be generated based on boundary condition of geometries.
            blockMeshDict: Optional input for blockMeshDict. If blockMeshDict is
                not provided, it will be calculated from geometries in XY
                direction and boundary condition for faces will be set to
                BoundingBoxBoundaryCondition. Use BlockMeshDict to create the
                blockMeshDict if your case is not aligned to XY direction or you
                need to assign different boundary condition to geometries.
            meshingParameters: Optional input for MeshingParameters.
            make2dParameters: Optional input for make2dParameters to make a 2d
                case.
        """
        geometries = cls.__checkInputGeometries(geometries)

        # update meshingParameters
        if not meshingParameters:
            meshingParameters = MeshingParameters()

        # create foam files
        if not blockMeshDict:
            minPt, maxPt = calculateMinMaxFromBFGeometries(geometries)
            blockMeshDict = BlockMeshDict.fromMinMax(minPt, maxPt, convertToMeters)

        if make2dParameters:
            # create the 2D blockMeshDict
            blockMeshDict.make2d(
                make2dParameters.origin, make2dParameters.normal,
                make2dParameters.width)

        blockMeshDict.updateMeshingParameters(meshingParameters)

        # set the locationInMesh for snappyHexMeshDict
        if make2dParameters:
            meshingParameters.locationInMesh = make2dParameters.origin
        if not meshingParameters.locationInMesh:
            meshingParameters.locationInMesh = blockMeshDict.center

        # rename name for snappyHexMeshDict and stl file if starts with a digit
        normname = '_{}'.format(name) if name[0].isdigit() else name
        snappyHexMeshDict = SnappyHexMeshDict.fromBFGeometries(
            normname, geometries, meshingParameters,
            convertToMeters=blockMeshDict.convertToMeters)

        # constant folder
        if float(Version.OFVer) < 3:
            turbulenceProperties = RASProperties()
        else:
            turbulenceProperties = TurbulenceProperties()
        transportProperties = TransportProperties()
        g = G()

        # 0 floder
        try:
            _geometries = geometries + blockMeshDict.geometry
        except TypeError:
            _geometries = tuple(geometries) + blockMeshDict.geometry

        u = U.fromBFGeometries(_geometries)
        p = P.fromBFGeometries(_geometries)
        k = K.fromBFGeometries(_geometries)
        epsilon = Epsilon.fromBFGeometries(_geometries)
        nut = Nut.fromBFGeometries(_geometries)
        t = T.fromBFGeometries(_geometries)
        alphat = Alphat.fromBFGeometries(_geometries)
        p_rgh = P_rgh.fromBFGeometries(_geometries)

        # system folder
        fvSchemes = FvSchemes()
        fvSolution = FvSolution()
        controlDict = ControlDict()
        probes = Probes()

        foamFiles = (blockMeshDict, snappyHexMeshDict, turbulenceProperties,
                     transportProperties, g, u, p, k, epsilon, nut, t, alphat,
                     p_rgh, fvSchemes, fvSolution, controlDict, probes)

        # create case
        _cls = cls(name, foamFiles, geometries)
        _cls.__originalName = normname
        return _cls

    @classmethod
    def fromWindTunnel(cls, windTunnel, make2dParameters=None):
        """Create case from wind tunnel."""
        _case = cls.fromBFGeometries(
            windTunnel.name, windTunnel.testGeomtries, windTunnel.blockMeshDict,
            windTunnel.meshingParameters, make2dParameters)

        initialConditions = InitialConditions(
            Uref=windTunnel.flowSpeed, Zref=windTunnel.Zref, z0=windTunnel.z0)

        ablConditions = ABLConditions.fromWindTunnel(windTunnel)

        # add initialConditions and ABLConditions to _case
        _case.addFoamFiles((initialConditions, ablConditions))

        # include condition files in 0 folder files
        _case.U.updateValues({'#include': '"initialConditions"',
                              'internalField': 'uniform $flowVelocity'},
                             mute=True)
        _case.p.updateValues({'#include': '"initialConditions"',
                              'internalField': 'uniform $pressure'},
                             mute=True)
        _case.k.updateValues({'#include': '"initialConditions"',
                              'internalField': 'uniform $turbulentKE'},
                             mute=True)
        _case.epsilon.updateValues({'#include': '"initialConditions"',
                                    'internalField': 'uniform $turbulentEpsilon'},
                                   mute=True)

        if windTunnel.refinementRegions:
            for region in windTunnel.refinementRegions:
                _case.addRefinementRegion(region)

        return _case

    @property
    def isCase(self):
        """return True."""
        return True

    @property
    def projectName(self):
        """Project name."""
        return self.__projectName

    @projectName.setter
    def projectName(self, name):
        assert re.match("^[a-zA-Z0-9_]*$", name), \
            'Invalid project name: "{}".\n' \
            'Do not use whitespace or special charecters.'.format(name)
        self.__projectName = name

    @property
    def geometries(self):
        """Butterfly geometries."""
        if hasattr(self, 'blockMeshDict'):
            try:
                return self.__geometries + self.blockMeshDict.geometry
            except TypeError:
                return tuple(self.__geometries) + self.blockMeshDict.geometry

        return self.__geometries

    @property
    def workingDir(self):
        """Change default working directory.

        Do not change the working dir if you are using OpenFOAM for Windows
        to run the analysis.
        """
        return self.__workingDir

    @workingDir.setter
    def workingDir(self, p):
        self.__workingDir = os.path.normpath(p)

    @property
    def projectDir(self):
        """Get project directory."""
        return os.path.join(self.workingDir, self.projectName)

    @property
    def zeroFolder(self):
        """Folder 0 fullpath."""
        return os.path.join(self.projectDir, '0')

    @property
    def constantFolder(self):
        """constant folder fullpath."""
        return os.path.join(self.projectDir, 'constant')

    @property
    def systemFolder(self):
        """system folder fullpath."""
        return os.path.join(self.projectDir, 'system')

    @property
    def logFolder(self):
        """log folder fullpath."""
        return os.path.join(self.projectDir, 'log')

    @property
    def polyMeshFolder(self):
        """polyMesh folder fullpath."""
        return os.path.join(self.projectDir, 'constant\\polyMesh')

    @property
    def triSurfaceFolder(self):
        """triSurface folder fullpath."""
        return os.path.join(self.projectDir, 'constant\\triSurface')

    @property
    def postProcessingFolder(self):
        """postProcessing folder fullpath."""
        return os.path.join(self.projectDir, 'postProcessing')

    @property
    def probesFolder(self):
        """Fullpath to probes folder."""
        return os.path.join(self.postProcessingFolder, 'probes')

    @property
    def foamFiles(self):
        """Get all the foamFiles."""
        return tuple(f for f in self.__foamfiles)

    @property
    def refinementRegions(self):
        """Get refinement regions."""
        return self.__refinementRegions

    @property
    def isPolyMeshSnappyHexMesh(self):
        """Check if the mesh in polyMesh folder is snappyHexMesh."""
        return len(os.listdir(self.polyMeshFolder)) > 5

    @property
    def probes(self):
        """Get and set Probes."""
        return self.__probes

    @probes.setter
    def probes(self, inp):
        if not inp:
            return

        assert hasattr(inp, 'probeLocations'), \
            "Expected Probes not {}".format(type(inp))

        self.__probes = inp
        if self.probes.probesCount > 0:
            # include probes in controlDict
            self.controlDict.include = self.probes.filename

    def getFoamFileByName(self, name):
        """Get a foamfile by name."""
        return self.__getFoamFileByName(name, self.foamFiles)

    def getSnappyHexMeshFolders(self):
        """Return sorted list of numerical folders."""
        _f = [int(name) for name in os.listdir(self.projectDir)
              if (name.isdigit() and
                  os.path.isdir(os.path.join(self.projectDir,
                                             name, 'polyMesh'))
                  )]

        _f.sort()

        return tuple(str(f) for f in _f)

    def getResultFolders(self):
        """Return sorted list of numerical folders."""
        _f = [int(name) for name in os.listdir(self.projectDir)
              if (name != '0' and name.isdigit() and
                  os.path.isdir(os.path.join(self.projectDir, name)) and
                  not os.path.isdir(os.path.join(self.projectDir, name, 'polyMesh'))
                  )]

        _f.sort()

        return tuple(str(f) for f in _f)

    def getFoamFilesFromLocation(self, location=None):
        """Get foamFiles in a specific location (0, constant, system)."""
        if not location:
            return tuple(f for f in self.__foamfiles)
        else:
            return tuple(f for f in self.__foamfiles
                         if f.location == '"{}"'.format(location))

    def addFoamFiles(self, foamfiles):
        """Add foamfiles to the Case."""
        for ff in foamfiles:
            self.addFoamFile(ff)

    def addFoamFile(self, foamfile):
        """Add a foamfile to the case."""
        if not foamfile:
            return
        assert hasattr(foamfile, 'isFoamFile'), \
            '{} is not a FoamFile'.format(foamfile)
        try:
            setattr(self, foamfile.name, foamfile)
            self.__foamfiles.append(foamfile)
        except AttributeError as e:
            raise ValueError('Failed to add {}.\n\t{}'.format(foamfile, e))

    def addRefinementRegions(self, refinementRegions):
        """Add a collections of refinement regions."""
        for refinementRegion in refinementRegions:
            self.addRefinementRegion(refinementRegion)

    def addRefinementRegion(self, refinementRegion):
        """Add a refinement region."""
        assert hasattr(refinementRegion, 'isRefinementRegion'), \
            "{} is not a refinement region.".format(refinementRegion)

        self.__refinementRegions.append(refinementRegion)
        assert hasattr(self, 'snappyHexMeshDict'), \
            'You can\'t add a refinementRegion to a case with no snappyHexMeshDict.'

        self.snappyHexMeshDict.addRefinementRegion(refinementRegion)

    def copySnappyHexMesh(self, folderNumber=None, overwrite=True):
        """Copy the results of snappyHexMesh to constant/polyMesh."""
        # pick the last numerical folder
        if folderNumber:
            _s = os.path.join(self.projectDir, str(folderNumber), 'polyMesh')
            assert os.path.isdir(_s), "Can't find {}.".format(_s)
        else:
            _folders = self.getSnappyHexMeshFolders()
            if not _folders:
                return
            _s = os.path.join(self.projectDir, _folders[-1], 'polyMesh')

        # copy files to constant/polyMesh
        if overwrite:
            self.removePolyMeshContent()

        try:
            copy_tree(_s, self.polyMeshFolder)
        except Exception as e:
            print("Failed to copy snappyHexMesh folder: {}".format(e))

    def renameSnappyHexMeshFolders(self, add=True):
        """Rename snappyHexMesh numerical folders to name.org  and vice versa.

        Args:
            add: Set to True to add .org at the end of the file. Set to False
                to rename them back to the original naming.
        """
        # find list of folders in project and collect the numbers
        if not add:
            _folders = (name for name in os.listdir(self.projectDir)
                        if (name.endswith('.org') and
                            os.path.isdir(os.path.join(self.projectDir, name,
                                                       'polyMesh'))))

            for f in _folders:
                os.rename(os.path.join(self.projectDir, f),
                          os.path.join(self.projectDir, f.replace('.org', '')))
        else:
            _folders = self.getSnappyHexMeshFolders()

            # rename them starting from 1
            for f in _folders:
                try:
                    os.rename(os.path.join(self.projectDir, f),
                              os.path.join(self.projectDir, '%s.org' % f))
                except Exception as e:
                    raise Exception('Failed to rename snappyHexMesh folders: {}'
                                    .format(e))

    def removeSnappyHexMeshFolders(self):
        """Remove snappyHexMesh numerical folders.

        Use this to clean the folder.
        """
        self.renameSnappyHexMeshFolders(add=False)
        _folders = self.getSnappyHexMeshFolders()

        for f in _folders:
            try:
                rmtree(os.path.join(self.projectDir, f))
            except Exception as e:
                print('Failed to remove {}:\n{}'.format(f, e))

    def removeResultFolders(self):
        """Remove results folder."""
        _folders = self.getResultFolders()
        for _f in _folders:
            try:
                rmtree(os.path.join(self.projectDir, _f))
            except Exception as e:
                print('Failed to remove {}:\n{}'.format(_f, e))

    def removePostProcessingFolder(self):
        """Remove post postProcessing folder."""
        if not os.path.isdir(self.postProcessingFolder):
            return

        try:
            rmtree(self.postProcessingFolder)
        except Exception as e:
            print('Failed to remove postProcessing folder:\n{}'.format(e))

    def removePolyMeshContent(self):
        """Remove files inside polyMesh folder."""
        for _f in os.listdir(self.polyMeshFolder):
            if _f != 'blockMeshDict':
                _fp = os.path.join(self.polyMeshFolder, _f)
                if os.path.isfile(_fp):
                    os.remove(_fp)
                elif os.path.isdir(_fp):
                    rmtree(_fp)

    def removeProcessorFolders(self):
        """Remove processor folders for parallel runs."""

        ff = (os.path.join(self.projectDir, d)
              for d in os.listdir(self.projectDir)
              if d.startswith('processor') and
              os.path.isdir(os.path.join(self.projectDir, d)))

        for f in ff:
            try:
                rmtree(f)
            except Exception as e:
                print('Failed to remove processor folder:\n{}'.format(e))

    def purge(self, removePolyMeshContent=True,
              removeSnappyHexMeshFolders=True,
              removeResultFolders=False,
              removePostProcessingFolder=False):
        """Purge case folder."""
        if removePolyMeshContent:
            self.removePolyMeshContent()
        if removeSnappyHexMeshFolders:
            self.removeSnappyHexMeshFolders()
        if removeResultFolders:
            self.removeResultFolders()
        if removePostProcessingFolder:
            self.removePostProcessingFolder()

    def updateBCInZeroFolder(self):
        """Update boundary conditions in files in 0 folder.

        Call this method if you have made any changes to boundary condition of
        any of the geometries after initiating the class.
        """
        raise NotImplementedError()

    def save(self, overwrite=False, minimum=True):
        """Save case to folder.

        Args:
            overwrite: If True all the current content will be overwritten
                (default: False).
            minimum: Write minimum necessary files for case. These files will
                be enough for meshing the case but not running any commands.
                Files are ('fvSchemes', 'fvSolution', 'controlDict',
                'blockMeshDict','snappyHexMeshDict'). Rest of the files will be
                created from a Solution.
        """
        # create folder and subfolders if they are not already created
        if overwrite and os.path.exists(self.projectDir):
            rmtree(self.projectDir, ignore_errors=True)

        for f in self.SUBFOLDERS:
            p = os.path.join(self.projectDir, f)
            if not os.path.exists(p):
                try:
                    os.makedirs(p)
                except Exception as e:
                    msg = 'Butterfly failed to create {}\n\t{}'.format(p, e)
                    if str(e).startswith('[Error 183]'):
                        print(msg)
                    else:
                        raise IOError(msg)

        # save foamfiles
        if minimum:
            foamFiles = (ff for ff in self.foamFiles
                         if ff.name in self.MINFOAMFILES)
        else:
            foamFiles = self.foamFiles

        for f in foamFiles:
            f.save(self.projectDir)

        # find blockMeshDict and convertToMeters so I can scale stl files to meters.
        bmds = (ff for ff in self.foamFiles if ff.name == 'blockMeshDict')
        bmd = bmds.next()
        convertToMeters = bmd.convertToMeters

        # write bfgeometries to stl file. __geometries is geometries without
        # blockMesh geometry
        stlStr = (geo.toSTL(convertToMeters) for geo in self.__geometries)
        stlName = self.__originalName or self.projectName
        with open(os.path.join(self.triSurfaceFolder,
                               '%s.stl' % stlName), 'wb') as stlf:
            stlf.writelines(stlStr)

        # write refinementRegions to stl files
        for ref in self.refinementRegions:
            ref.writeToStl(self.triSurfaceFolder, convertToMeters)

        # add .foam file
        with open(os.path.join(self.projectDir,
                               self.projectName + '.foam'), 'wb') as ffile:
            ffile.write('')

        print('{} is saved to: {}'.format(self.projectName, self.projectDir))

    def command(self, cmd, args=None, decomposeParDict=None, run=True, wait=True):
        ur"""Run an OpenFOAM command for this case.
        This method creates a log and err file under logFolder for each command.
        The output will be logged as {cmd}.log and {cmd}.err.
        Args:
            cmd: OpenFOAM command.
            args: Command arguments.
            decomposeParDict: Optional input for decomposeParDict to run analysis
                in parallel if desired.
            run: Run the command in shell.
            wait: Wait until the command is over.
        returns:
            If run is True returns a namedtuple for
                (success, error, process, logfiles, errorfiles).
                success: as a boolen.
                error: None in case of success otherwise the error message as
                    a string.
                process: Popen process.
                logfiles: List of fullpath to log files.
                errorfiles: List of fullpath to error files.
            else return a namedtuple for
                (cmd, logfiles, errorfiles)
                cmd: command lines.
                logfiles: A tuple for log files.
                errorfiles: A tuple for error files.
        """
        if not run:
            cmdlog = self.runmanager.command(cmd, args, decomposeParDict)
            return cmdlog
        else:
            log = namedtuple('log', 'success error process logfiles errorfiles')

            p, logfiles, errfiles = self.runmanager.run(cmd, args,
                                                        decomposeParDict, wait)

            logfiles = tuple(os.path.normpath(os.path.join(self.projectDir, f))
                             for f in logfiles)

            errfiles = tuple(os.path.normpath(os.path.join(self.projectDir, f))
                             for f in errfiles)

            # check error files and raise and error
            if wait:
                self.runmanager.checkFileContents(logfiles, mute=False)
                hascontent, content = self.runmanager.checkFileContents(errfiles)

                return log(not hascontent, content, p, logfiles, errfiles)
            else:
                # return a namedtuple assuming that the command is running fine.
                return log(True, None, p, logfiles, errfiles)

    def blockMesh(self, args=None, wait=True, overwrite=True,):
        """Run blockMesh.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
            overwrite: Overwrite current content of the folder.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        if overwrite:
            self.removePolyMeshContent()

        return self.command('blockMesh', args, decomposeParDict=None,
                            wait=wait)

    def surfaceFeatureExtract(self, args=None, wait=True):
        """Run surfaceFeatureExtract command.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        # create surfaceFeatureExtractDict if it's not created
        return self.command('surfaceFeatureExtract', args, decomposeParDict=None,
                            wait=wait)

    # TODO(Mostapha): Sample for multiple fields.
    # The reason we don't have it now is that I don't have the methods in place
    # for dealing with lists of lists in Grasshopper.
    def sample(self, name, points, field, wait=True):
        """Sample the results for a certain field.

        Args:
            name: A unique name for this sample.
            points: List of points as (x, y, z).
            fields: List of fields (e.g. U, p).
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(probes, values).
        """
        sd = SampleDict.fromPoints(name, points, (field,))
        sd.save(self.projectDir)

        log = self.command(
            'postProcess', args=('-func', 'sampleDict', '-latestTime'),
            decomposeParDict=None, wait=wait)

        if not log.success:
            raise Exception("Failed to sample the case:\n\t%s"
                            % log.error)

        rf = list(int(f) for f in self.getResultFolders())
        rf.sort()

        fp = tuple(os.path.join(self.postProcessingFolder, 'sampleDict', str(rf[-1]), f)
                   for f in sd.outputFilenames)

        if fp:
            res = loadProbesAndValuesFromSampleFile(fp[0])
            pts, values = izip(*(r for r in res))
            res = namedtuple('Results', 'probes values')
            return res(pts, values)

    def snappyHexMesh(self, args=None, wait=True):
        """Run snappyHexMesh.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        return self.command('snappyHexMesh', args, self.decomposeParDict,
                            wait=wait)

    def checkMesh(self, args=None, wait=True):
        """Run checkMesh.

        Args:
            args: Command arguments.
            wait: Wait until command execution ends.
        Returns:
            namedtuple(success, error, process, logfiles, errorfiles).
        """
        return self.command('checkMesh', args, self.decomposeParDict,
                            wait=wait)

    def calculateMeshOrthogonality(self, useCurrntCheckMeshLog=False):
        """Calculate max and average mesh orthogonality.

        If average values is more than 80, try to generate a better mesh.
        You can use this values to set discretization schemes.
        try case.setFvSchemes(averageOrthogonality)
        """
        if not useCurrntCheckMeshLog:
            log = self.checkMesh(args=('-latestTime',))
            assert log.success, log.error

        f = os.path.join(self.logFolder, 'checkMesh.log')
        assert os.path.isfile(f), 'Failed to find {}.'.format(f)

        with open(f, 'rb') as inf:
            results = ''.join(inf.readlines())
            maximum, average = results \
                .split('Mesh non-orthogonality Max:')[-1] \
                .split('average:')[:2]

            average = average.split('\n')[0]

        return float(maximum), float(average)

    @staticmethod
    def __getFoamFileByName(name, foamfiles):
        """Get a foamfile by name."""
        for f in foamfiles:
            if f.name == name:
                return f

    @staticmethod
    def __createFoamfileFromFile(p, convertToMeters=1):
        """Create a foamfile object from an OpenFOAM foamfile.

        Args:
            p: Fullpath to file.
        Return:
            A Butterfly foam file.
        """
        # Butterfly FoamFiles. This dictionary should be expanded.
        __foamfilescollection = {
            'turbulenceProperties': TurbulenceProperties,
            'RASProperties': RASProperties,
            'transportProperties': TransportProperties, 'g': G,
            'U': U, 'k': K, 'p': P, 'nut': Nut, 'epsilon': Epsilon, 'T': T,
            'alphat': Alphat, 'p_rgh': P_rgh, 'ABLConditions': ABLConditions,
            'initialConditions': InitialConditions,
            'blockMeshDict': BlockMeshDict, 'snappyHexMeshDict': SnappyHexMeshDict,
            'controlDict': ControlDict, 'fvSchemes': FvSchemes,
            'fvSolution': FvSolution, 'probes': Probes,
            'decomposeParDict': DecomposeParDict
        }

        name = os.path.split(p)[-1].split('.')[0]
        if name == 'blockMeshDict':
            try:
                return BlockMeshDict.fromFile(p, convertToMeters)
            except Exception as e:
                print('Failed to import {}:\n\t{}'.format(p, e))
        elif name in __foamfilescollection:
            try:
                return __foamfilescollection[name].fromFile(p)
            except Exception as e:
                print('Failed to import {}:\n\t{}'.format(p, e))
        else:
            return FoamFile.fromFile(p)

    @staticmethod
    def __checkInputGeometries(geos):
        for geo in geos:
            assert hasattr(geo, 'isBFMesh'), \
                'Expected butterfly.Mesh not {}'.format(geo)
        return geos

    def loadMesh(self):
        """Return OpenFOAM mesh as a Rhino mesh."""
        # This is a abstract property which should be implemented in subclasses
        raise NotImplementedError()

    def loadPoints(self):
        """Return OpenFOAM mesh as a Rhino mesh."""
        # This is a abstract property which should be implemented in subclasses
        raise NotImplementedError()

    def loadProbeValues(self, field):
        """Return OpenFOAM probes results for a field."""
        if self.probes.probesCount == 0:
            return ()

        if field not in self.probes.fields:
            raise ValueError("Can't find {} in {}.".format(field,
                                                           self.probes.fields))

        return loadProbeValuesFromFolder(self.probesFolder, field)

    def loadProbes(self, field):
        """Return OpenFOAM probes locations for a field."""
        if self.probes.probesCount == 0:
            return ()

        if field not in self.probes.fields:
            raise ValueError("Can't find {} in {}.".format(field,
                                                           self.probes.fields))

        return loadProbesFromPostProcessingFile(self.probesFolder, field)

    def duplicate(self):
        """Return a copy of this object."""
        return deepcopy(self)

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """OpenFOAM CASE."""
        return "OpenFOAM CASE: %s" % self.projectName
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#butterfly.case.Case">Case</a></li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Class variables</h3>
            <div class="item">
            <p id="butterfly.case.Case.MINFOAMFILES" class="name">var <span class="ident">MINFOAMFILES</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.SUBFOLDERS" class="name">var <span class="ident">SUBFOLDERS</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
          <h3>Instance variables</h3>
            <div class="item">
            <p id="butterfly.case.Case.constantFolder" class="name">var <span class="ident">constantFolder</span></p>
            

            
  
    <div class="desc"><p>constant folder fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.decomposeParDict" class="name">var <span class="ident">decomposeParDict</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.foamFiles" class="name">var <span class="ident">foamFiles</span></p>
            

            
  
    <div class="desc"><p>Get all the foamFiles.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.geometries" class="name">var <span class="ident">geometries</span></p>
            

            
  
    <div class="desc"><p>Butterfly geometries.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.isCase" class="name">var <span class="ident">isCase</span></p>
            

            
  
    <div class="desc"><p>return True.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.isPolyMeshSnappyHexMesh" class="name">var <span class="ident">isPolyMeshSnappyHexMesh</span></p>
            

            
  
    <div class="desc"><p>Check if the mesh in polyMesh folder is snappyHexMesh.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.logFolder" class="name">var <span class="ident">logFolder</span></p>
            

            
  
    <div class="desc"><p>log folder fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.polyMeshFolder" class="name">var <span class="ident">polyMeshFolder</span></p>
            

            
  
    <div class="desc"><p>polyMesh folder fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.postProcessingFolder" class="name">var <span class="ident">postProcessingFolder</span></p>
            

            
  
    <div class="desc"><p>postProcessing folder fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.probes" class="name">var <span class="ident">probes</span></p>
            

            
  
    <div class="desc"><p>Get and set Probes.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.probesFolder" class="name">var <span class="ident">probesFolder</span></p>
            

            
  
    <div class="desc"><p>Fullpath to probes folder.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.projectDir" class="name">var <span class="ident">projectDir</span></p>
            

            
  
    <div class="desc"><p>Get project directory.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.projectName" class="name">var <span class="ident">projectName</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.refinementRegions" class="name">var <span class="ident">refinementRegions</span></p>
            

            
  
    <div class="desc"><p>Get refinement regions.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.runmanager" class="name">var <span class="ident">runmanager</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.systemFolder" class="name">var <span class="ident">systemFolder</span></p>
            

            
  
    <div class="desc"><p>system folder fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.triSurfaceFolder" class="name">var <span class="ident">triSurfaceFolder</span></p>
            

            
  
    <div class="desc"><p>triSurface folder fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.workingDir" class="name">var <span class="ident">workingDir</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.case.Case.zeroFolder" class="name">var <span class="ident">zeroFolder</span></p>
            

            
  
    <div class="desc"><p>Folder 0 fullpath.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, name, foamfiles, geometries)</p>
    </div>
    

    
  
    <div class="desc"><p>Init case.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.__init__', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.__init__" class="source">
    <pre><code>def __init__(self, name, foamfiles, geometries):
    """Init case."""
    # original name is a variable to address the current limitation to change
    # the name of stl file in snappyHexMeshDict. It will be removed once the
    # limitation is addressed. The value wil be assigned in classmethod fromFile
    self.__originalName = None
    self.projectName = name
    self.__version = float(Version.OFVer)
    self.decomposeParDict = None
    # optional input for changing working directory
    # should not be used on OpenFOAM on Windows
    self.workingDir = os.path.join(os.path.expanduser('~'), 'butterfly')
    # set foamfiles dynamically. This is flexible but makes documentation
    # tricky. also autocomplete won't work for this cases.
    self.__foamfiles = []
    self.addFoamFiles(foamfiles)
    # set butterfly geometries
    self.__geometries = self.__checkInputGeometries(geometries)
    # place holder for refinment regions
    # use .addRefinementRegions to add regions to case
    self.__refinementRegions = []
    self.runmanager = RunManager(self.projectName)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.ToString">
    <p>def <span class="ident">ToString</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrite .NET ToString method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.ToString', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.ToString" class="source">
    <pre><code>def ToString(self):
    """Overwrite .NET ToString method."""
    return self.__repr__()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.addFoamFile">
    <p>def <span class="ident">addFoamFile</span>(</p><p>self, foamfile)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a foamfile to the case.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.addFoamFile', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.addFoamFile" class="source">
    <pre><code>def addFoamFile(self, foamfile):
    """Add a foamfile to the case."""
    if not foamfile:
        return
    assert hasattr(foamfile, 'isFoamFile'), \
        '{} is not a FoamFile'.format(foamfile)
    try:
        setattr(self, foamfile.name, foamfile)
        self.__foamfiles.append(foamfile)
    except AttributeError as e:
        raise ValueError('Failed to add {}.\n\t{}'.format(foamfile, e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.addFoamFiles">
    <p>def <span class="ident">addFoamFiles</span>(</p><p>self, foamfiles)</p>
    </div>
    

    
  
    <div class="desc"><p>Add foamfiles to the Case.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.addFoamFiles', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.addFoamFiles" class="source">
    <pre><code>def addFoamFiles(self, foamfiles):
    """Add foamfiles to the Case."""
    for ff in foamfiles:
        self.addFoamFile(ff)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.addRefinementRegion">
    <p>def <span class="ident">addRefinementRegion</span>(</p><p>self, refinementRegion)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a refinement region.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.addRefinementRegion', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.addRefinementRegion" class="source">
    <pre><code>def addRefinementRegion(self, refinementRegion):
    """Add a refinement region."""
    assert hasattr(refinementRegion, 'isRefinementRegion'), \
        "{} is not a refinement region.".format(refinementRegion)
    self.__refinementRegions.append(refinementRegion)
    assert hasattr(self, 'snappyHexMeshDict'), \
        'You can\'t add a refinementRegion to a case with no snappyHexMeshDict.'
    self.snappyHexMeshDict.addRefinementRegion(refinementRegion)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.addRefinementRegions">
    <p>def <span class="ident">addRefinementRegions</span>(</p><p>self, refinementRegions)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a collections of refinement regions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.addRefinementRegions', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.addRefinementRegions" class="source">
    <pre><code>def addRefinementRegions(self, refinementRegions):
    """Add a collections of refinement regions."""
    for refinementRegion in refinementRegions:
        self.addRefinementRegion(refinementRegion)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.blockMesh">
    <p>def <span class="ident">blockMesh</span>(</p><p>self, args=None, wait=True, overwrite=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Run blockMesh.</p>
<p>Args:
    args: Command arguments.
    wait: Wait until command execution ends.
    overwrite: Overwrite current content of the folder.
Returns:
    namedtuple(success, error, process, logfiles, errorfiles).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.blockMesh', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.blockMesh" class="source">
    <pre><code>def blockMesh(self, args=None, wait=True, overwrite=True,):
    """Run blockMesh.
    Args:
        args: Command arguments.
        wait: Wait until command execution ends.
        overwrite: Overwrite current content of the folder.
    Returns:
        namedtuple(success, error, process, logfiles, errorfiles).
    """
    if overwrite:
        self.removePolyMeshContent()
    return self.command('blockMesh', args, decomposeParDict=None,
                        wait=wait)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.calculateMeshOrthogonality">
    <p>def <span class="ident">calculateMeshOrthogonality</span>(</p><p>self, useCurrntCheckMeshLog=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Calculate max and average mesh orthogonality.</p>
<p>If average values is more than 80, try to generate a better mesh.
You can use this values to set discretization schemes.
try case.setFvSchemes(averageOrthogonality)</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.calculateMeshOrthogonality', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.calculateMeshOrthogonality" class="source">
    <pre><code>def calculateMeshOrthogonality(self, useCurrntCheckMeshLog=False):
    """Calculate max and average mesh orthogonality.
    If average values is more than 80, try to generate a better mesh.
    You can use this values to set discretization schemes.
    try case.setFvSchemes(averageOrthogonality)
    """
    if not useCurrntCheckMeshLog:
        log = self.checkMesh(args=('-latestTime',))
        assert log.success, log.error
    f = os.path.join(self.logFolder, 'checkMesh.log')
    assert os.path.isfile(f), 'Failed to find {}.'.format(f)
    with open(f, 'rb') as inf:
        results = ''.join(inf.readlines())
        maximum, average = results \
            .split('Mesh non-orthogonality Max:')[-1] \
            .split('average:')[:2]
        average = average.split('\n')[0]
    return float(maximum), float(average)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.checkMesh">
    <p>def <span class="ident">checkMesh</span>(</p><p>self, args=None, wait=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Run checkMesh.</p>
<p>Args:
    args: Command arguments.
    wait: Wait until command execution ends.
Returns:
    namedtuple(success, error, process, logfiles, errorfiles).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.checkMesh', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.checkMesh" class="source">
    <pre><code>def checkMesh(self, args=None, wait=True):
    """Run checkMesh.
    Args:
        args: Command arguments.
        wait: Wait until command execution ends.
    Returns:
        namedtuple(success, error, process, logfiles, errorfiles).
    """
    return self.command('checkMesh', args, self.decomposeParDict,
                        wait=wait)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.command">
    <p>def <span class="ident">command</span>(</p><p>self, cmd, args=None, decomposeParDict=None, run=True, wait=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Run an OpenFOAM command for this case.
This method creates a log and err file under logFolder for each command.
The output will be logged as {cmd}.log and {cmd}.err.
Args:
    cmd: OpenFOAM command.
    args: Command arguments.
    decomposeParDict: Optional input for decomposeParDict to run analysis
        in parallel if desired.
    run: Run the command in shell.
    wait: Wait until the command is over.
returns:
    If run is True returns a namedtuple for
        (success, error, process, logfiles, errorfiles).
        success: as a boolen.
        error: None in case of success otherwise the error message as
            a string.
        process: Popen process.
        logfiles: List of fullpath to log files.
        errorfiles: List of fullpath to error files.
    else return a namedtuple for
        (cmd, logfiles, errorfiles)
        cmd: command lines.
        logfiles: A tuple for log files.
        errorfiles: A tuple for error files.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.command', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.command" class="source">
    <pre><code>def command(self, cmd, args=None, decomposeParDict=None, run=True, wait=True):
    ur"""Run an OpenFOAM command for this case.
    This method creates a log and err file under logFolder for each command.
    The output will be logged as {cmd}.log and {cmd}.err.
    Args:
        cmd: OpenFOAM command.
        args: Command arguments.
        decomposeParDict: Optional input for decomposeParDict to run analysis
            in parallel if desired.
        run: Run the command in shell.
        wait: Wait until the command is over.
    returns:
        If run is True returns a namedtuple for
            (success, error, process, logfiles, errorfiles).
            success: as a boolen.
            error: None in case of success otherwise the error message as
                a string.
            process: Popen process.
            logfiles: List of fullpath to log files.
            errorfiles: List of fullpath to error files.
        else return a namedtuple for
            (cmd, logfiles, errorfiles)
            cmd: command lines.
            logfiles: A tuple for log files.
            errorfiles: A tuple for error files.
    """
    if not run:
        cmdlog = self.runmanager.command(cmd, args, decomposeParDict)
        return cmdlog
    else:
        log = namedtuple('log', 'success error process logfiles errorfiles')
        p, logfiles, errfiles = self.runmanager.run(cmd, args,
                                                    decomposeParDict, wait)
        logfiles = tuple(os.path.normpath(os.path.join(self.projectDir, f))
                         for f in logfiles)
        errfiles = tuple(os.path.normpath(os.path.join(self.projectDir, f))
                         for f in errfiles)
        # check error files and raise and error
        if wait:
            self.runmanager.checkFileContents(logfiles, mute=False)
            hascontent, content = self.runmanager.checkFileContents(errfiles)
            return log(not hascontent, content, p, logfiles, errfiles)
        else:
            # return a namedtuple assuming that the command is running fine.
            return log(True, None, p, logfiles, errfiles)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.copySnappyHexMesh">
    <p>def <span class="ident">copySnappyHexMesh</span>(</p><p>self, folderNumber=None, overwrite=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Copy the results of snappyHexMesh to constant/polyMesh.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.copySnappyHexMesh', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.copySnappyHexMesh" class="source">
    <pre><code>def copySnappyHexMesh(self, folderNumber=None, overwrite=True):
    """Copy the results of snappyHexMesh to constant/polyMesh."""
    # pick the last numerical folder
    if folderNumber:
        _s = os.path.join(self.projectDir, str(folderNumber), 'polyMesh')
        assert os.path.isdir(_s), "Can't find {}.".format(_s)
    else:
        _folders = self.getSnappyHexMeshFolders()
        if not _folders:
            return
        _s = os.path.join(self.projectDir, _folders[-1], 'polyMesh')
    # copy files to constant/polyMesh
    if overwrite:
        self.removePolyMeshContent()
    try:
        copy_tree(_s, self.polyMeshFolder)
    except Exception as e:
        print("Failed to copy snappyHexMesh folder: {}".format(e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a copy of this object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.duplicate" class="source">
    <pre><code>def duplicate(self):
    """Return a copy of this object."""
    return deepcopy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.fromBFGeometries">
    <p>def <span class="ident">fromBFGeometries</span>(</p><p>cls, name, geometries, blockMeshDict=None, meshingParameters=None, make2dParameters=None, convertToMeters=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a case from Butterfly geometries.</p>
<p>foamFiles/dictionaries will be generated based on boundary condition of
geometries. fvSolution and fvSchemes will be set to default can can be
overwritten once a Solution is created from a Case and a Recipe. You can
overwrite them through the recipe.</p>
<p>Args:
    name: Case name as a string with no whitespace.
    geometries: Collection of BFGeometries. FoamFiles/dictionaries will
        be generated based on boundary condition of geometries.
    blockMeshDict: Optional input for blockMeshDict. If blockMeshDict is
        not provided, it will be calculated from geometries in XY
        direction and boundary condition for faces will be set to
        BoundingBoxBoundaryCondition. Use BlockMeshDict to create the
        blockMeshDict if your case is not aligned to XY direction or you
        need to assign different boundary condition to geometries.
    meshingParameters: Optional input for MeshingParameters.
    make2dParameters: Optional input for make2dParameters to make a 2d
        case.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.fromBFGeometries', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.fromBFGeometries" class="source">
    <pre><code>@classmethod
def fromBFGeometries(cls, name, geometries, blockMeshDict=None,
                     meshingParameters=None, make2dParameters=None,
                     convertToMeters=1):
    """Create a case from Butterfly geometries.
    foamFiles/dictionaries will be generated based on boundary condition of
    geometries. fvSolution and fvSchemes will be set to default can can be
    overwritten once a Solution is created from a Case and a Recipe. You can
    overwrite them through the recipe.
    Args:
        name: Case name as a string with no whitespace.
        geometries: Collection of BFGeometries. FoamFiles/dictionaries will
            be generated based on boundary condition of geometries.
        blockMeshDict: Optional input for blockMeshDict. If blockMeshDict is
            not provided, it will be calculated from geometries in XY
            direction and boundary condition for faces will be set to
            BoundingBoxBoundaryCondition. Use BlockMeshDict to create the
            blockMeshDict if your case is not aligned to XY direction or you
            need to assign different boundary condition to geometries.
        meshingParameters: Optional input for MeshingParameters.
        make2dParameters: Optional input for make2dParameters to make a 2d
            case.
    """
    geometries = cls.__checkInputGeometries(geometries)
    # update meshingParameters
    if not meshingParameters:
        meshingParameters = MeshingParameters()
    # create foam files
    if not blockMeshDict:
        minPt, maxPt = calculateMinMaxFromBFGeometries(geometries)
        blockMeshDict = BlockMeshDict.fromMinMax(minPt, maxPt, convertToMeters)
    if make2dParameters:
        # create the 2D blockMeshDict
        blockMeshDict.make2d(
            make2dParameters.origin, make2dParameters.normal,
            make2dParameters.width)
    blockMeshDict.updateMeshingParameters(meshingParameters)
    # set the locationInMesh for snappyHexMeshDict
    if make2dParameters:
        meshingParameters.locationInMesh = make2dParameters.origin
    if not meshingParameters.locationInMesh:
        meshingParameters.locationInMesh = blockMeshDict.center
    # rename name for snappyHexMeshDict and stl file if starts with a digit
    normname = '_{}'.format(name) if name[0].isdigit() else name
    snappyHexMeshDict = SnappyHexMeshDict.fromBFGeometries(
        normname, geometries, meshingParameters,
        convertToMeters=blockMeshDict.convertToMeters)
    # constant folder
    if float(Version.OFVer) < 3:
        turbulenceProperties = RASProperties()
    else:
        turbulenceProperties = TurbulenceProperties()
    transportProperties = TransportProperties()
    g = G()
    # 0 floder
    try:
        _geometries = geometries + blockMeshDict.geometry
    except TypeError:
        _geometries = tuple(geometries) + blockMeshDict.geometry
    u = U.fromBFGeometries(_geometries)
    p = P.fromBFGeometries(_geometries)
    k = K.fromBFGeometries(_geometries)
    epsilon = Epsilon.fromBFGeometries(_geometries)
    nut = Nut.fromBFGeometries(_geometries)
    t = T.fromBFGeometries(_geometries)
    alphat = Alphat.fromBFGeometries(_geometries)
    p_rgh = P_rgh.fromBFGeometries(_geometries)
    # system folder
    fvSchemes = FvSchemes()
    fvSolution = FvSolution()
    controlDict = ControlDict()
    probes = Probes()
    foamFiles = (blockMeshDict, snappyHexMeshDict, turbulenceProperties,
                 transportProperties, g, u, p, k, epsilon, nut, t, alphat,
                 p_rgh, fvSchemes, fvSolution, controlDict, probes)
    # create case
    _cls = cls(name, foamFiles, geometries)
    _cls.__originalName = normname
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.fromFolder">
    <p>def <span class="ident">fromFolder</span>(</p><p>cls, path, name=None, convertFromMeters=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a Butterfly case from a case folder.</p>
<p>Args:
    path: Full path to case folder.
    name: An optional new name for this case.
    convertFromMeters: A number to be multiplied to stl file vertices
        to be converted to the new units if not meters. This value will
        be the inverse of convertToMeters.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.fromFolder', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.fromFolder" class="source">
    <pre><code>@classmethod
def fromFolder(cls, path, name=None, convertFromMeters=1):
    """Create a Butterfly case from a case folder.
    Args:
        path: Full path to case folder.
        name: An optional new name for this case.
        convertFromMeters: A number to be multiplied to stl file vertices
            to be converted to the new units if not meters. This value will
            be the inverse of convertToMeters.
    """
    # collect foam files
    __originalName = os.path.split(path)[-1]
    if not name:
        name = __originalName
    _files = loadCaseFiles(path, fullpath=True)
    # convert files to butterfly objects
    ff = []
    for f in (_files.zero, _files.constant, _files.system):
        for p in f:
            if not p:
                continue
            try:
                ff.append(cls.__createFoamfileFromFile(p, 1.0 / convertFromMeters))
                print('Imported {} from case.'.format(p))
            except Exception as e:
                print('Failed to import {}:\n\t{}'.format(p, e))
    sHMD = cls.__getFoamFileByName('snappyHexMeshDict', ff)
    if sHMD:
        sHMD.projectName = name
        stlfiles = tuple(f for f in _files.stl if f.lower().endswith('.stl'))
        bfGeometries = tuple(
            geo for f in stlfiles
            for geo in bfGeometryFromStlFile(f, convertFromMeters)
            if os.path.split(f)[-1][:-4] in sHMD.stlFileNames)
    else:
        bfGeometries = []
    _case = cls(name, ff, bfGeometries)
    # update each field of boundary condition for geometries
    for ff in _case.getFoamFilesFromLocation('0'):
        for geo in _case.geometries:
            try:
                f = ff.getBoundaryField(geo.name)
            except AttributeError as e:
                if not geo.name.endswith('Conditions'):
                    print(str(e))
            else:
                # set boundary condition for the field
                if not f:
                    setattr(geo.boundaryCondition, ff.name, None)
                else:
                    setattr(geo.boundaryCondition, ff.name, Field.fromDict(f))
    if sHMD:
        refinementRegions = tuple(
            ref for f in _files.stl
            if os.path.split(f)[-1][:-4] in sHMD.refinementRegionNames
            for ref in refinementRegionsFromStlFile(
                f, sHMD.refinementRegionMode(os.path.split(f)[-1][:-4]))
        )
        _case.addRefinementRegions(refinementRegions)
    # original name is a variable to address the current limitation to change
    # the name of stl file in snappyHexMeshDict. It will be removed once the
    # limitation is addressed.
    _case.__originalName = __originalName
    return _case
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.fromWindTunnel">
    <p>def <span class="ident">fromWindTunnel</span>(</p><p>cls, windTunnel, make2dParameters=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create case from wind tunnel.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.fromWindTunnel', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.fromWindTunnel" class="source">
    <pre><code>@classmethod
def fromWindTunnel(cls, windTunnel, make2dParameters=None):
    """Create case from wind tunnel."""
    _case = cls.fromBFGeometries(
        windTunnel.name, windTunnel.testGeomtries, windTunnel.blockMeshDict,
        windTunnel.meshingParameters, make2dParameters)
    initialConditions = InitialConditions(
        Uref=windTunnel.flowSpeed, Zref=windTunnel.Zref, z0=windTunnel.z0)
    ablConditions = ABLConditions.fromWindTunnel(windTunnel)
    # add initialConditions and ABLConditions to _case
    _case.addFoamFiles((initialConditions, ablConditions))
    # include condition files in 0 folder files
    _case.U.updateValues({'#include': '"initialConditions"',
                          'internalField': 'uniform $flowVelocity'},
                         mute=True)
    _case.p.updateValues({'#include': '"initialConditions"',
                          'internalField': 'uniform $pressure'},
                         mute=True)
    _case.k.updateValues({'#include': '"initialConditions"',
                          'internalField': 'uniform $turbulentKE'},
                         mute=True)
    _case.epsilon.updateValues({'#include': '"initialConditions"',
                                'internalField': 'uniform $turbulentEpsilon'},
                               mute=True)
    if windTunnel.refinementRegions:
        for region in windTunnel.refinementRegions:
            _case.addRefinementRegion(region)
    return _case
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.getFoamFileByName">
    <p>def <span class="ident">getFoamFileByName</span>(</p><p>self, name)</p>
    </div>
    

    
  
    <div class="desc"><p>Get a foamfile by name.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.getFoamFileByName', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.getFoamFileByName" class="source">
    <pre><code>def getFoamFileByName(self, name):
    """Get a foamfile by name."""
    return self.__getFoamFileByName(name, self.foamFiles)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.getFoamFilesFromLocation">
    <p>def <span class="ident">getFoamFilesFromLocation</span>(</p><p>self, location=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Get foamFiles in a specific location (0, constant, system).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.getFoamFilesFromLocation', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.getFoamFilesFromLocation" class="source">
    <pre><code>def getFoamFilesFromLocation(self, location=None):
    """Get foamFiles in a specific location (0, constant, system)."""
    if not location:
        return tuple(f for f in self.__foamfiles)
    else:
        return tuple(f for f in self.__foamfiles
                     if f.location == '"{}"'.format(location))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.getResultFolders">
    <p>def <span class="ident">getResultFolders</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return sorted list of numerical folders.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.getResultFolders', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.getResultFolders" class="source">
    <pre><code>def getResultFolders(self):
    """Return sorted list of numerical folders."""
    _f = [int(name) for name in os.listdir(self.projectDir)
          if (name != '0' and name.isdigit() and
              os.path.isdir(os.path.join(self.projectDir, name)) and
              not os.path.isdir(os.path.join(self.projectDir, name, 'polyMesh'))
              )]
    _f.sort()
    return tuple(str(f) for f in _f)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.getSnappyHexMeshFolders">
    <p>def <span class="ident">getSnappyHexMeshFolders</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return sorted list of numerical folders.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.getSnappyHexMeshFolders', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.getSnappyHexMeshFolders" class="source">
    <pre><code>def getSnappyHexMeshFolders(self):
    """Return sorted list of numerical folders."""
    _f = [int(name) for name in os.listdir(self.projectDir)
          if (name.isdigit() and
              os.path.isdir(os.path.join(self.projectDir,
                                         name, 'polyMesh'))
              )]
    _f.sort()
    return tuple(str(f) for f in _f)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.loadMesh">
    <p>def <span class="ident">loadMesh</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return OpenFOAM mesh as a Rhino mesh.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.loadMesh', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.loadMesh" class="source">
    <pre><code>def loadMesh(self):
    """Return OpenFOAM mesh as a Rhino mesh."""
    # This is a abstract property which should be implemented in subclasses
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.loadPoints">
    <p>def <span class="ident">loadPoints</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return OpenFOAM mesh as a Rhino mesh.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.loadPoints', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.loadPoints" class="source">
    <pre><code>def loadPoints(self):
    """Return OpenFOAM mesh as a Rhino mesh."""
    # This is a abstract property which should be implemented in subclasses
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.loadProbeValues">
    <p>def <span class="ident">loadProbeValues</span>(</p><p>self, field)</p>
    </div>
    

    
  
    <div class="desc"><p>Return OpenFOAM probes results for a field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.loadProbeValues', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.loadProbeValues" class="source">
    <pre><code>def loadProbeValues(self, field):
    """Return OpenFOAM probes results for a field."""
    if self.probes.probesCount == 0:
        return ()
    if field not in self.probes.fields:
        raise ValueError("Can't find {} in {}.".format(field,
                                                       self.probes.fields))
    return loadProbeValuesFromFolder(self.probesFolder, field)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.loadProbes">
    <p>def <span class="ident">loadProbes</span>(</p><p>self, field)</p>
    </div>
    

    
  
    <div class="desc"><p>Return OpenFOAM probes locations for a field.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.loadProbes', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.loadProbes" class="source">
    <pre><code>def loadProbes(self, field):
    """Return OpenFOAM probes locations for a field."""
    if self.probes.probesCount == 0:
        return ()
    if field not in self.probes.fields:
        raise ValueError("Can't find {} in {}.".format(field,
                                                       self.probes.fields))
    return loadProbesFromPostProcessingFile(self.probesFolder, field)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.purge">
    <p>def <span class="ident">purge</span>(</p><p>self, removePolyMeshContent=True, removeSnappyHexMeshFolders=True, removeResultFolders=False, removePostProcessingFolder=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Purge case folder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.purge', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.purge" class="source">
    <pre><code>def purge(self, removePolyMeshContent=True,
          removeSnappyHexMeshFolders=True,
          removeResultFolders=False,
          removePostProcessingFolder=False):
    """Purge case folder."""
    if removePolyMeshContent:
        self.removePolyMeshContent()
    if removeSnappyHexMeshFolders:
        self.removeSnappyHexMeshFolders()
    if removeResultFolders:
        self.removeResultFolders()
    if removePostProcessingFolder:
        self.removePostProcessingFolder()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.removePolyMeshContent">
    <p>def <span class="ident">removePolyMeshContent</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove files inside polyMesh folder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.removePolyMeshContent', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.removePolyMeshContent" class="source">
    <pre><code>def removePolyMeshContent(self):
    """Remove files inside polyMesh folder."""
    for _f in os.listdir(self.polyMeshFolder):
        if _f != 'blockMeshDict':
            _fp = os.path.join(self.polyMeshFolder, _f)
            if os.path.isfile(_fp):
                os.remove(_fp)
            elif os.path.isdir(_fp):
                rmtree(_fp)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.removePostProcessingFolder">
    <p>def <span class="ident">removePostProcessingFolder</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove post postProcessing folder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.removePostProcessingFolder', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.removePostProcessingFolder" class="source">
    <pre><code>def removePostProcessingFolder(self):
    """Remove post postProcessing folder."""
    if not os.path.isdir(self.postProcessingFolder):
        return
    try:
        rmtree(self.postProcessingFolder)
    except Exception as e:
        print('Failed to remove postProcessing folder:\n{}'.format(e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.removeProcessorFolders">
    <p>def <span class="ident">removeProcessorFolders</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove processor folders for parallel runs.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.removeProcessorFolders', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.removeProcessorFolders" class="source">
    <pre><code>def removeProcessorFolders(self):
    """Remove processor folders for parallel runs."""
    ff = (os.path.join(self.projectDir, d)
          for d in os.listdir(self.projectDir)
          if d.startswith('processor') and
          os.path.isdir(os.path.join(self.projectDir, d)))
    for f in ff:
        try:
            rmtree(f)
        except Exception as e:
            print('Failed to remove processor folder:\n{}'.format(e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.removeResultFolders">
    <p>def <span class="ident">removeResultFolders</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove results folder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.removeResultFolders', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.removeResultFolders" class="source">
    <pre><code>def removeResultFolders(self):
    """Remove results folder."""
    _folders = self.getResultFolders()
    for _f in _folders:
        try:
            rmtree(os.path.join(self.projectDir, _f))
        except Exception as e:
            print('Failed to remove {}:\n{}'.format(_f, e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.removeSnappyHexMeshFolders">
    <p>def <span class="ident">removeSnappyHexMeshFolders</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove snappyHexMesh numerical folders.</p>
<p>Use this to clean the folder.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.removeSnappyHexMeshFolders', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.removeSnappyHexMeshFolders" class="source">
    <pre><code>def removeSnappyHexMeshFolders(self):
    """Remove snappyHexMesh numerical folders.
    Use this to clean the folder.
    """
    self.renameSnappyHexMeshFolders(add=False)
    _folders = self.getSnappyHexMeshFolders()
    for f in _folders:
        try:
            rmtree(os.path.join(self.projectDir, f))
        except Exception as e:
            print('Failed to remove {}:\n{}'.format(f, e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.renameSnappyHexMeshFolders">
    <p>def <span class="ident">renameSnappyHexMeshFolders</span>(</p><p>self, add=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Rename snappyHexMesh numerical folders to name.org  and vice versa.</p>
<p>Args:
    add: Set to True to add .org at the end of the file. Set to False
        to rename them back to the original naming.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.renameSnappyHexMeshFolders', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.renameSnappyHexMeshFolders" class="source">
    <pre><code>def renameSnappyHexMeshFolders(self, add=True):
    """Rename snappyHexMesh numerical folders to name.org  and vice versa.
    Args:
        add: Set to True to add .org at the end of the file. Set to False
            to rename them back to the original naming.
    """
    # find list of folders in project and collect the numbers
    if not add:
        _folders = (name for name in os.listdir(self.projectDir)
                    if (name.endswith('.org') and
                        os.path.isdir(os.path.join(self.projectDir, name,
                                                   'polyMesh'))))
        for f in _folders:
            os.rename(os.path.join(self.projectDir, f),
                      os.path.join(self.projectDir, f.replace('.org', '')))
    else:
        _folders = self.getSnappyHexMeshFolders()
        # rename them starting from 1
        for f in _folders:
            try:
                os.rename(os.path.join(self.projectDir, f),
                          os.path.join(self.projectDir, '%s.org' % f))
            except Exception as e:
                raise Exception('Failed to rename snappyHexMesh folders: {}'
                                .format(e))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.sample">
    <p>def <span class="ident">sample</span>(</p><p>self, name, points, field, wait=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Sample the results for a certain field.</p>
<p>Args:
    name: A unique name for this sample.
    points: List of points as (x, y, z).
    fields: List of fields (e.g. U, p).
    args: Command arguments.
    wait: Wait until command execution ends.
Returns:
    namedtuple(probes, values).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.sample', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.sample" class="source">
    <pre><code>def sample(self, name, points, field, wait=True):
    """Sample the results for a certain field.
    Args:
        name: A unique name for this sample.
        points: List of points as (x, y, z).
        fields: List of fields (e.g. U, p).
        args: Command arguments.
        wait: Wait until command execution ends.
    Returns:
        namedtuple(probes, values).
    """
    sd = SampleDict.fromPoints(name, points, (field,))
    sd.save(self.projectDir)
    log = self.command(
        'postProcess', args=('-func', 'sampleDict', '-latestTime'),
        decomposeParDict=None, wait=wait)
    if not log.success:
        raise Exception("Failed to sample the case:\n\t%s"
                        % log.error)
    rf = list(int(f) for f in self.getResultFolders())
    rf.sort()
    fp = tuple(os.path.join(self.postProcessingFolder, 'sampleDict', str(rf[-1]), f)
               for f in sd.outputFilenames)
    if fp:
        res = loadProbesAndValuesFromSampleFile(fp[0])
        pts, values = izip(*(r for r in res))
        res = namedtuple('Results', 'probes values')
        return res(pts, values)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.save">
    <p>def <span class="ident">save</span>(</p><p>self, overwrite=False, minimum=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Save case to folder.</p>
<p>Args:
    overwrite: If True all the current content will be overwritten
        (default: False).
    minimum: Write minimum necessary files for case. These files will
        be enough for meshing the case but not running any commands.
        Files are ('fvSchemes', 'fvSolution', 'controlDict',
        'blockMeshDict','snappyHexMeshDict'). Rest of the files will be
        created from a Solution.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.save', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.save" class="source">
    <pre><code>def save(self, overwrite=False, minimum=True):
    """Save case to folder.
    Args:
        overwrite: If True all the current content will be overwritten
            (default: False).
        minimum: Write minimum necessary files for case. These files will
            be enough for meshing the case but not running any commands.
            Files are ('fvSchemes', 'fvSolution', 'controlDict',
            'blockMeshDict','snappyHexMeshDict'). Rest of the files will be
            created from a Solution.
    """
    # create folder and subfolders if they are not already created
    if overwrite and os.path.exists(self.projectDir):
        rmtree(self.projectDir, ignore_errors=True)
    for f in self.SUBFOLDERS:
        p = os.path.join(self.projectDir, f)
        if not os.path.exists(p):
            try:
                os.makedirs(p)
            except Exception as e:
                msg = 'Butterfly failed to create {}\n\t{}'.format(p, e)
                if str(e).startswith('[Error 183]'):
                    print(msg)
                else:
                    raise IOError(msg)
    # save foamfiles
    if minimum:
        foamFiles = (ff for ff in self.foamFiles
                     if ff.name in self.MINFOAMFILES)
    else:
        foamFiles = self.foamFiles
    for f in foamFiles:
        f.save(self.projectDir)
    # find blockMeshDict and convertToMeters so I can scale stl files to meters.
    bmds = (ff for ff in self.foamFiles if ff.name == 'blockMeshDict')
    bmd = bmds.next()
    convertToMeters = bmd.convertToMeters
    # write bfgeometries to stl file. __geometries is geometries without
    # blockMesh geometry
    stlStr = (geo.toSTL(convertToMeters) for geo in self.__geometries)
    stlName = self.__originalName or self.projectName
    with open(os.path.join(self.triSurfaceFolder,
                           '%s.stl' % stlName), 'wb') as stlf:
        stlf.writelines(stlStr)
    # write refinementRegions to stl files
    for ref in self.refinementRegions:
        ref.writeToStl(self.triSurfaceFolder, convertToMeters)
    # add .foam file
    with open(os.path.join(self.projectDir,
                           self.projectName + '.foam'), 'wb') as ffile:
        ffile.write('')
    print('{} is saved to: {}'.format(self.projectName, self.projectDir))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.snappyHexMesh">
    <p>def <span class="ident">snappyHexMesh</span>(</p><p>self, args=None, wait=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Run snappyHexMesh.</p>
<p>Args:
    args: Command arguments.
    wait: Wait until command execution ends.
Returns:
    namedtuple(success, error, process, logfiles, errorfiles).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.snappyHexMesh', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.snappyHexMesh" class="source">
    <pre><code>def snappyHexMesh(self, args=None, wait=True):
    """Run snappyHexMesh.
    Args:
        args: Command arguments.
        wait: Wait until command execution ends.
    Returns:
        namedtuple(success, error, process, logfiles, errorfiles).
    """
    return self.command('snappyHexMesh', args, self.decomposeParDict,
                        wait=wait)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.surfaceFeatureExtract">
    <p>def <span class="ident">surfaceFeatureExtract</span>(</p><p>self, args=None, wait=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Run surfaceFeatureExtract command.</p>
<p>Args:
    args: Command arguments.
    wait: Wait until command execution ends.
Returns:
    namedtuple(success, error, process, logfiles, errorfiles).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.surfaceFeatureExtract', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.surfaceFeatureExtract" class="source">
    <pre><code>def surfaceFeatureExtract(self, args=None, wait=True):
    """Run surfaceFeatureExtract command.
    Args:
        args: Command arguments.
        wait: Wait until command execution ends.
    Returns:
        namedtuple(success, error, process, logfiles, errorfiles).
    """
    # create surfaceFeatureExtractDict if it's not created
    return self.command('surfaceFeatureExtract', args, decomposeParDict=None,
                        wait=wait)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.case.Case.updateBCInZeroFolder">
    <p>def <span class="ident">updateBCInZeroFolder</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Update boundary conditions in files in 0 folder.</p>
<p>Call this method if you have made any changes to boundary condition of
any of the geometries after initiating the class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.case.Case.updateBCInZeroFolder', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.case.Case.updateBCInZeroFolder" class="source">
    <pre><code>def updateBCInZeroFolder(self):
    """Update boundary conditions in files in 0 folder.
    Call this method if you have made any changes to boundary condition of
    any of the geometries after initiating the class.
    """
    raise NotImplementedError()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a>
    </p>
  </footer>
</div>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
