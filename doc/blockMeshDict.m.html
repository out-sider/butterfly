<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>butterfly.blockMeshDict API documentation</title>
    <meta name="description" content="BlockMeshDict class." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>

  <!-- highlight.js for highlighting source code. -->
  <link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/styles/default.min.css">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.2.0/highlight.min.js"></script>

  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 0.9em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    margin-left: 25%;
    max-width: 90%;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    position: fixed;
    height: 100%;
    width: 25%;
    float: left;
    padding: 30px;
    overflow-x: hidden;
    overflow-y: auto;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; }

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;

      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: auto;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }

  .desc {
    white-space: pre-wrap;
  }

  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
        position: inherit;
        float: none;
        width: auto;
    }
    #content {
      width: 95%;
      margin-left: auto;
      border-left: none;
      padding: 30px;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#butterfly.blockMeshDict.BlockMeshDict">BlockMeshDict</a></span>
        
          
  <ul>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.convertBoolValue">convertBoolValue</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.__init__">__init__</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.ToString">ToString</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.body">body</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.duplicate">duplicate</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.expandByCellsCount">expandByCellsCount</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.expandUniform">expandUniform</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.expandUniformByCellsCount">expandUniformByCellsCount</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.expandX">expandX</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.expandY">expandY</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.expandZ">expandZ</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries">fromBFBlockGeometries</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromFile">fromFile</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromMinMax">fromMinMax</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize">fromOriginAndSize</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.fromVertices">fromVertices</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.getFaceIndices">getFaceIndices</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.getFaceVertices">getFaceVertices</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.getValueByParameter">getValueByParameter</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.header">header</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.make2d">make2d</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.make3d">make3d</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize">nDivXYZByCellSize</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.save">save</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.setValueByParameter">setValueByParameter</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM">toOpenFOAM</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters">updateMeshingParameters</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.updateValues">updateValues</a></li>
    <li class="mono"><a href="#butterfly.blockMeshDict.BlockMeshDict.updateVertices">updateVertices</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">butterfly.blockMeshDict</span> module</h1>
  <p>BlockMeshDict class.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict" class="source">
    <pre><code># coding=utf-8
"""BlockMeshDict class."""
from .boundarycondition import BoundingBoxBoundaryCondition, EmptyBoundaryCondition
from .foamfile import FoamFile
import vectormath
from .grading import SimpleGrading, Grading, MultiGrading
from .parser import CppDictParser
from .geometry import BFGeometry
from math import sqrt, sin, cos, radians
from collections import OrderedDict


class BlockMeshDict(FoamFile):
    """BlockMeshDict."""

    __defaultValues = OrderedDict()
    __defaultValues['convertToMeters'] = 1
    __defaultValues['vertices'] = None
    __defaultValues['blocks'] = None
    __defaultValues['boundary'] = {}

    def __init__(self, values=None):
        """Init class."""
        FoamFile.__init__(self, name='blockMeshDict', cls='dictionary',
                          location='system', defaultValues=self.__defaultValues,
                          values=values)

        self.__BFBlockGeometries = None  # this will be overwritten in classmethods
        self.__vertices = None
        self.__isFromVertices = False
        # variables for 2d blockMeshDict
        self.__is2dInXDir = False
        self.__is2dInYDir = False
        self.__is2dInZDir = False
        self.__original3dVertices = None

    @classmethod
    def fromFile(cls, filepah, convertToMeters=1):
        """Create a blockMeshDict from file.

        Args:
            filepah: Full path to blockMeshDict.
            converToMeters: converToMeters for the new document. This values
                will be used to update the vertices to the new units. Default
                is 1 which means blockMeshDict will be converted to meters.
        """
        _cls = cls()

        with open(filepah, 'rb') as bf:
            lines = CppDictParser._removeComments(bf.read())
            bmd = ' '.join(lines.replace('\r\n', ' ').replace('\n', ' ').split())

        _cls.values['convertToMeters'] = convertToMeters

        originalConvertToMeters = float(bmd.split('convertToMeters')[-1].split(';')[0])

        conversion = convertToMeters / originalConvertToMeters

        # find vertices
        vertices = list(eval(','.join(bmd.split('vertices')[-1]
                                      .split(';')[0]
                                      .strip()[1:-1]
                                      .split())))

        _cls.__vertices = list(tuple(i / conversion for i in v)
                               for v in vertices)

        # get blocks, order of vertices, nDivXYZ, grading
        blocks = bmd.split('blocks')[-1].split(';')[0].strip()
        xyz, simpleGrading = blocks.split('simpleGrading')

        _cls.__order, _cls.nDivXYZ = eval(','.join(xyz.split('hex')[-1].split()))

        simpleGrading = eval(','.join(simpleGrading.strip()[:-1]
                                      .replace('( ', '(')
                                      .replace(' )', ')')
                                      .split()))

        _cls.grading = SimpleGrading(
            *(MultiGrading(tuple(Grading(*i) for i in g))
              if isinstance(g, tuple) else Grading(g)
              for g in simpleGrading))

        # recreate boundary faces
        boundaryString = bmd.replace(' (', '(').replace(' )', ')') \
            .split('boundary(')[-1].strip().replace('});', '}') \
            .replace('));', ');').replace('((', ' (').replace(')(', ') (')

        _cls.values['boundary'] = {}
        for key, values in CppDictParser(boundaryString).values.iteritems():
            if isinstance(values, dict) and 'type' in values and 'faces' in values:
                values['faces'] = eval(str(values['faces']).replace(' ', ','))

                _cls.values['boundary'][key] = values

        del((lines, bmd))
        return _cls

    @classmethod
    def fromOriginAndSize(cls, origin, width, length, height, convertToMeters=1,
                          nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            origin: Minimum point of bounding box as (x, y, z).
            width: Width in x direction.
            length: Length in y direction.
            height: Height in y direction.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        vertices = [
            vectormath.move(origin,
                            vectormath.sums((vectormath.scale(_xAxis, i * width),
                                             vectormath.scale(_yAxis, j * length),
                                             vectormath.scale(_zAxis, k * height))
                                            ))
            for i in range(2) for j in range(2) for k in range(2)]

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromMinMax(cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None,
                   xAxis=None):
        """Create BlockMeshDict from minimum and maximum point.

        Args:
            minPt: Minimum point of bounding box as (x, y, z).
            maxPt: Maximum point of bounding box as (x, y, z).
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        diagonal2D = tuple(i - j for i, j in zip(maxPt, minPt))[:2]
        _angle = radians(vectormath.angleAnitclockwise(_xAxis[:2], diagonal2D))
        width = cos(_angle) * vectormath.length(diagonal2D)
        length = sin(_angle) * vectormath.length(diagonal2D)
        height = maxPt[2] - minPt[2]

        vertices = [
            vectormath.move(minPt,
                            vectormath.sums((vectormath.scale(_xAxis, i * width),
                                             vectormath.scale(_yAxis, j * length),
                                             vectormath.scale(_zAxis, k * height))
                                            ))

            for i in range(2) for j in range(2) for k in range(2)]

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromVertices(cls, vertices, convertToMeters=1, nDivXYZ=None,
                     grading=None, xAxis=None):
        """Create BlockMeshDict from vertices.

        Args:
            vertices: 8 vertices to define the bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__rawvertices = vertices

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)

        _cls.__vertices = _cls.__sortVertices()

        _cls.__order = tuple(range(8))

        # update self.values['boundary']
        _cls.__updateBoundaryFromSortedVertices()

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading
        _cls.__isFromVertices = True
        return _cls

    @classmethod
    def fromBFBlockGeometries(cls, BFBlockGeometries, convertToMeters=1,
                              nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            BFBlockGeometries: A collection of boundary surfaces for bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__BFBlockGeometries = BFBlockGeometries

        try:
            # collect uniqe vertices from all BFGeometries
            _cls.__rawvertices = tuple(
                set(v for f in _cls.__BFBlockGeometries
                    for vgroup in f.borderVertices
                    for v in vgroup))
        except AttributeError as e:
            raise TypeError('At least one of the input geometries is not a '
                            'Butterfly block geometry:\n\t{}'.format(e))

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
        _cls.__vertices = _cls.__sortVertices()

        # update self.values['boundary']
        _cls.__updateBoundaryFromBFBlockGeometries()

        _cls.__order = tuple(range(8))

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading

        return _cls

    @property
    def convertToMeters(self):
        """Get convertToMeters."""
        return self.values['convertToMeters']

    @property
    def boundary(self):
        """Get boundaries and a dictionary."""
        return self.values['boundary']

    @property
    def is2dInXDirection(self):
        """Return True if the case is 2d in X direction."""
        return self.__is2dInXDir

    @property
    def is2dInYDirection(self):
        """Return True if the case is 2d in Y direction."""
        return self.__is2dInYDir

    @property
    def is2dInZDirection(self):
        """Return True if the case is 2d in Z direction."""
        return self.__is2dInZDir

    @property
    def vertices(self):
        """Get the sorted list of vertices."""
        return self.__vertices

    def updateVertices(self, vertices, xAxis=None):
        """Update blockMeshDict vertices."""
        self.__rawvertices = vertices

        # sort vertices
        self.xAxis = xAxis[:2] if xAxis else (1, 0)

        self.__vertices = self.__sortVertices()

        self.__order = tuple(range(8))

        # update self.values['boundary']
        self.__updateBoundaryFromSortedVertices()

    @property
    def verticesOrder(self):
        """Get order of vertices in blocks."""
        return self.__order

    @property
    def geometry(self):
        """A tuple of BFGeometries for BoundingBox faces."""
        def __getBFGeometry(name, attr):
            if name == 'boundingbox_empty':
                bc = EmptyBoundaryCondition()
            else:
                bc = BoundingBoxBoundaryCondition()

            ind = attr['faces'] if hasattr(attr['faces'][0], '__iter__') else \
                (attr['faces'],)

            # unique indecies
            uniuqe = tuple(set(i for inx in ind for i in inx))

            renumberedIndx = tuple(tuple(uniuqe.index(i) for i in inx)
                                   for inx in ind)

            return BFGeometry(name, tuple(self.vertices[i] for i in uniuqe),
                              renumberedIndx, boundaryCondition=bc)

        if not self.__BFBlockGeometries:
            self.__BFBlockGeometries = tuple(
                __getBFGeometry(name, attr)
                for name, attr in self.boundary.iteritems())

        return self.__BFBlockGeometries

    @property
    def width(self):
        """Length of block in X direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[1]])

    @property
    def length(self):
        """Length of block in Y direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[3]])

    @property
    def height(self):
        """Length of block in Z direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[4]])

    @property
    def center(self):
        """Get center of the block."""
        return self.__averageVerices()

    @property
    def minZ(self):
        """Return minimum Z value of vertices in this block."""
        return self.vertices[self.verticesOrder[0]][2]

    @property
    def nDivXYZ(self):
        """Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5)."""
        return self.__nDivXYZ

    @nDivXYZ.setter
    def nDivXYZ(self, dXYZ):
        self.__nDivXYZ = tuple(int(v) for v in dXYZ) if dXYZ else (5, 5, 5)
        if self.__is2dInXDir:
            self.__nDivXYZ = 1, self.__nDivXYZ[1], self.__nDivXYZ[2]
        elif self.__is2dInYDir:
            self.__nDivXYZ = self.__nDivXYZ[0], 1, self.__nDivXYZ[2]
        elif self.__is2dInZDir:
            self.__nDivXYZ = self.__nDivXYZ[0], self.__nDivXYZ[1], 1

    @property
    def grading(self):
        """A simpleGrading (default: simpleGrading(1, 1, 1))."""
        return self.__grading

    @grading.setter
    def grading(self, g):
        self.__grading = g if g else SimpleGrading()

        assert hasattr(self.grading, 'isSimpleGrading'), \
            'grading input ({}) is not a valid simpleGrading.'.format(g)

    def make3d(self):
        """Reload the 3d blockMeshDict if it has been converted to 2d."""
        if not self.__original3dVertices:
            print('This blockMeshDict is already a 3d blockMeshDict.')
            return
        self.__vertices = self.__original3dVertices
        self.__is2dInXDir = False
        self.__is2dInYDir = False
        self.__is2dInZDir = False

    def make2d(self, planeOrigin, planeNormal, width=0.1):
        """Make the blockMeshDict two dimensional.

        Args:
            planeOrigin: Plane origin as (x, y, z).
            planeNormal: Plane normal as (x, y, z).
            width: width of 2d blockMeshDict (default: 01).
        """
        # copy original vertices
        if not self.__original3dVertices:
            self.__original3dVertices = self.vertices
        else:
            # load original 3d vertices
            self.make3d()

        n = vectormath.normalize(planeNormal)

        # project all vertices to plane and move them in direction of normal
        # by half of width
        self.__vertices = [
            self.__calculate2dPoints(v, planeOrigin, n, width)
            for v in self.vertices]

        # set boundary condition to empty
        # and number of divisions to 1 in shortest side
        minimum = min(self.width, self.length, self.height)
        if self.width == minimum:
            self.nDivXYZ = (1, self.nDivXYZ[1], self.nDivXYZ[2])
            self.__is2dInXDir = True
            # set both sides to empty
            self.__setBoundaryToEmpty(4)
            self.__setBoundaryToEmpty(5)

        elif self.length == minimum:
            self.nDivXYZ = (self.nDivXYZ[0], 1, self.nDivXYZ[2])
            self.__is2dInYDir = True
            # set inlet and outlet to empty
            self.__setBoundaryToEmpty(0)
            self.__setBoundaryToEmpty(1)

        elif self.height == minimum:
            self.nDivXYZ = (self.nDivXYZ[0], self.nDivXYZ[1], 1)
            self.__is2dInZDir = True
            # set top and bottom to empty
            self.__setBoundaryToEmpty(2)
            self.__setBoundaryToEmpty(3)

    def expandUniformByCellsCount(self, count, renumberDivision=True):
        """Expand blockMeshDict boundingbox for n cells from all sides.

        This method will increase the number of divisions by 2 to keep the size
        of the cells unchanged unless renumberDivision is set to False. Use a
        negative count to shrink the bounding box.
        """
        x, y, z = self.nDivXYZ
        self.expandX((self.width / float(x)) * count)
        self.expandY((self.length / float(y)) * count)
        self.expandZ((self.height / float(z)) * count)
        if renumberDivision:
            self.nDivXYZ = (x + 2 * count, y + 2 * count, z + 2 * count)

    def expandByCellsCount(self, xCount, yCount, zCount, renumberDivision=True):
        """Expand blockMeshDict boundingbox for n cells from all sides.

        This method will increase the number of divisions by 2 to keep the size
        of the cells unchanged unless renumberDivision is set to False. Use a
        negative count to shrink the bounding box.
        """
        x, y, z = self.nDivXYZ
        self.expandX((self.width / float(x)) * xCount)
        self.expandY((self.length / float(y)) * yCount)
        self.expandZ((self.height / float(z)) * zCount)
        if renumberDivision:
            self.nDivXYZ = (x + 2 * xCount, y + 2 * yCount, z + 2 * zCount)

    def expandUniform(self, dist):
        """Expand blockMeshDict boundingbox for dist in all directions."""
        if not dist:
            return
        self.expandX(dist)
        self.expandY(dist)
        self.expandZ(dist)

    def expandX(self, dist):
        """Expand blockMeshDict boundingbox for dist in x and -x directions."""
        _xAxis = (self.xAxis[0], self.xAxis[1], 0) if len(self.xAxis) == 2 \
            else self.xAxis

        for i in (0, 3, 7, 4):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_xAxis, -dist))

        for i in (1, 2, 6, 5):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_xAxis, dist))

    def expandY(self, dist):
        """Expand blockMeshDict boundingbox for dist in y and -y directions."""
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, self.xAxis)
        for i in (0, 1, 5, 4):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_yAxis, -dist))

        for i in (3, 2, 6, 7):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_yAxis, dist))

    def expandZ(self, dist):
        """Expand blockMeshDict boundingbox for dist in z and -z directions."""
        _zAxis = (0, 0, 1)
        for i in (0, 1, 2, 3):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_zAxis, -dist))

        for i in (4, 5, 6, 7):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_zAxis, dist))

    @staticmethod
    def __calculate2dPoints(v, o, n, w):
        # project point
        p = vectormath.project(v, o, n)
        # move the projected point backwards for half of the width
        t = vectormath.scale(vectormath.normalize(vectormath.subtract(v, p)),
                             w / 2.0)
        return vectormath.move(p, t)

    def nDivXYZByCellSize(self, cellSizeXYZ):
        """Set number of divisions by cell size."""
        x, y, z = cellSizeXYZ
        self.nDivXYZ = int(round(self.width / x)), int(round(self.length / y)), \
            int(round(self.height / z))

    def updateMeshingParameters(self, meshingParameters):
        """Update meshing parameters for blockMeshDict."""
        if not meshingParameters:
            return

        assert hasattr(meshingParameters, 'isMeshingParameters'), \
            'Expected MeshingParameters not {}'.format(type(meshingParameters))

        if meshingParameters.cellSizeXYZ:
            self.nDivXYZByCellSize(meshingParameters.cellSizeXYZ)

        if meshingParameters.grading:
            self.grading = meshingParameters.grading

    @property
    def bottomFaceIndices(self):
        """Get indecies for bottom face."""
        return (self.verticesOrder[0], self.verticesOrder[3],
                self.verticesOrder[2], self.verticesOrder[1])

    @property
    def topFaceIndices(self):
        """Get indecies for top face."""
        return (self.verticesOrder[4], self.verticesOrder[5],
                self.verticesOrder[6], self.verticesOrder[7])

    @property
    def rightFaceIndices(self):
        """Get indecies for right face."""
        return (self.verticesOrder[1], self.verticesOrder[2],
                self.verticesOrder[6], self.verticesOrder[5])

    @property
    def leftFaceIndices(self):
        """Get indecies for left face."""
        return (self.verticesOrder[3], self.verticesOrder[0],
                self.verticesOrder[4], self.verticesOrder[7])

    @property
    def frontFaceIndices(self):
        """Get indecies for front face."""
        return (self.verticesOrder[0], self.verticesOrder[1],
                self.verticesOrder[5], self.verticesOrder[4])

    @property
    def backFaceIndices(self):
        """Get indecies for back face."""
        return (self.verticesOrder[2], self.verticesOrder[3],
                self.verticesOrder[7], self.verticesOrder[6])

    def getFaceIndices(self, faceIndex):
        """Update boundary to empty for one of the faces.

        Args:
            faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
                5 - left.
        """
        faceIndices = {0: self.frontFaceIndices, 1: self.backFaceIndices,
                       2: self.bottomFaceIndices, 3: self.topFaceIndices,
                       4: self.rightFaceIndices, 5: self.leftFaceIndices}

        return faceIndices[faceIndex]

    @property
    def bottomFaceVertices(self):
        """Get vertices for bottom face."""
        return tuple(self.vertices[o] for o in self.bottomFaceIndices)

    @property
    def topFaceVertices(self):
        """Get vertices for top face."""
        return tuple(self.vertices[o] for o in self.topFaceIndices)

    @property
    def rightFaceVertices(self):
        """Get vertices for right face."""
        return tuple(self.vertices[o] for o in self.rightFaceIndices)

    @property
    def leftFaceVertices(self):
        """Get vertices for left face."""
        return tuple(self.vertices[o] for o in self.leftFaceIndices)

    @property
    def frontFaceVertices(self):
        """Get vertices for front face."""
        return tuple(self.vertices[o] for o in self.frontFaceIndices)

    @property
    def backFaceVertices(self):
        """Get vertices for back face."""
        return tuple(self.vertices[o] for o in self.backFaceIndices)

    def getFaceVertices(self, faceIndex):
        """Update boundary to empty for one of the faces.

        Args:
            faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
                5 - left.
        """
        faceVertices = {0: self.frontFaceVertices, 1: self.backFaceVertices,
                        2: self.bottomFaceVertices, 3: self.topFaceVertices,
                        4: self.rightFaceVertices, 5: self.leftFaceVertices}

        return faceVertices[faceIndex]

    def __setBoundaryToEmpty(self, faceIndex):
        """Update boundary to empty for the face based on index.

        Args:
            faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
                5 - left.
        """
        # get indices and vertices for the faceIndex
        ind = self.getFaceIndices(faceIndex)

        if self.__isFromVertices:
            if 'boundingbox_empty' not in self.values['boundary']:
                self.values['boundary']['boundingbox_empty'] = \
                    {'type': 'empty', 'faces': ()}

            self.values['boundary']['boundingbox_empty']['faces'] += (ind,)
            self.values['boundary']['boundingbox']['faces'] = tuple(
                o for o in self.values['boundary']['boundingbox']['faces']
                if o != ind
            )
        else:
            # update boundary condition for the geometry if the boundary is created
            # from geometry
            for name, v in self.values['boundary'].iteritems():
                if ind in v['faces']:
                    v['type'] = 'empty'

                    for geo in self.__BFBlockGeometries:
                        if geo.name == name:
                            geo.boundaryCondition = EmptyBoundaryCondition()
                    break

    def __updateBoundaryFromSortedVertices(self):
        """Update boundary dictionary based ordered vertices."""
        self.values['boundary']['boundingbox'] = {
            'type': 'wall',
            'faces': (self.bottomFaceIndices, self.topFaceIndices,
                      self.rightFaceIndices, self.leftFaceIndices,
                      self.frontFaceIndices, self.backFaceIndices,
                      )
        }

    def __updateBoundaryFromBFBlockGeometries(self):
        """Update boundary dictionary based on BFBlockGeometries input."""
        for geo in self.__BFBlockGeometries:
            try:
                self.values['boundary'][geo.name] = {
                    'type': geo.boundaryCondition.type,
                    'faces': tuple(tuple(self.vertices.index(v) for v in verGroup)
                                   for verGroup in geo.borderVertices)
                }
            except AttributeError as e:
                raise TypeError('Wrong input geometry!\n{}'.format(e))

    def __boundaryToOpenFOAM(self):
        _body = "   %s\n" \
                "   {\n" \
                "       type %s;\n" \
                "       faces\n" \
                "       (" \
                "       %s\n" \
                "       );\n" \
                "   }\n"

        col = (_body % (name, attr['type'],
                        '\n' + '\n'.join('\t' + str(indices).replace(",", "")
                                         for indices in attr['faces']))
               if isinstance(attr['faces'][0], tuple) else
               _body % (name, attr['type'],
                        '\n\t' + str(attr['faces']).replace(",", ""))
               for name, attr in self.boundary.iteritems())

        return 'boundary\n(%s);\n' % '\n'.join(col)

    @staticmethod
    def __distance(v1, v2):
        return sqrt(sum((x - y) ** 2 for x, y in zip(v1, v2)))

    def __averageVerices(self):
        _x, _y, _z = 0, 0, 0

        for ver in self.__rawvertices:
            _x += ver[0]
            _y += ver[1]
            _z += ver[2]

        numofver = len(self.__rawvertices)
        return _x / numofver, _y / numofver, _z / numofver

    def __sortVertices(self):
        """sort input vertices."""
        groups = {}
        for p in self.__rawvertices:
            if p[2] not in groups:
                groups[p[2]] = []

            groups[p[2]].append((p[0], p[1]))

        zValues = groups.keys()
        zValues.sort()
        pointGroups = groups.values()

        assert len(zValues) == 2, \
            'Number of Z values must be 2 not {}: {}.'.format(len(zValues),
                                                              zValues)

        for g in pointGroups:
            assert len(g) == 4

        # the points in both height are identical so I just take the first group
        # and sort them
        xAxisReversed = (-self.xAxis[0], -self.xAxis[1])
        centerPt = self.center[:2]
        sortedPoints2d = \
            sorted(pointGroups[0],
                   key=lambda x: vectormath.angleAnitclockwise(
                       xAxisReversed, tuple(c1 - c2 for c1, c2
                                            in zip(x, centerPt))))

        sortedPoints = [(pt[0], pt[1], z) for z in zValues for pt in sortedPoints2d]
        return sortedPoints

    def toOpenFOAM(self):
        """Return OpenFOAM representation as a string."""
        _hea = self.header()
        _body = "\nconvertToMeters %.4f;\n" \
                "\n" \
                "vertices\n" \
                "(\n\t%s\n);\n" \
                "\n" \
                "blocks\n" \
                "(\nhex %s %s %s\n);\n" \
                "\n" \
                "edges\n" \
                "(%s);\n" \
                "\n" \
                "%s" \
                "\n" \
                "mergePatchPair\n" \
                "(%s);\n"

        return _hea + \
            _body % (
                self.convertToMeters,
                "\n\t".join(tuple(str(ver).replace(",", "")
                                  for ver in self.vertices)),
                str(self.verticesOrder).replace(",", ""),
                str(self.nDivXYZ).replace(",", ""),
                self.grading,  # blocks
                "\n",  # edges
                self.__boundaryToOpenFOAM(),  # boundary
                "\n")  # merge patch pair

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """BlockMeshDict representation."""
        return self.toOpenFOAM()
</code></pre>
  </div>

  </header>

  <section id="section-items">


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="butterfly.blockMeshDict.BlockMeshDict" class="name">class <span class="ident">BlockMeshDict</span></p>
      
  
    <div class="desc"><p>BlockMeshDict.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict" class="source">
    <pre><code>class BlockMeshDict(FoamFile):
    """BlockMeshDict."""

    __defaultValues = OrderedDict()
    __defaultValues['convertToMeters'] = 1
    __defaultValues['vertices'] = None
    __defaultValues['blocks'] = None
    __defaultValues['boundary'] = {}

    def __init__(self, values=None):
        """Init class."""
        FoamFile.__init__(self, name='blockMeshDict', cls='dictionary',
                          location='system', defaultValues=self.__defaultValues,
                          values=values)

        self.__BFBlockGeometries = None  # this will be overwritten in classmethods
        self.__vertices = None
        self.__isFromVertices = False
        # variables for 2d blockMeshDict
        self.__is2dInXDir = False
        self.__is2dInYDir = False
        self.__is2dInZDir = False
        self.__original3dVertices = None

    @classmethod
    def fromFile(cls, filepah, convertToMeters=1):
        """Create a blockMeshDict from file.

        Args:
            filepah: Full path to blockMeshDict.
            converToMeters: converToMeters for the new document. This values
                will be used to update the vertices to the new units. Default
                is 1 which means blockMeshDict will be converted to meters.
        """
        _cls = cls()

        with open(filepah, 'rb') as bf:
            lines = CppDictParser._removeComments(bf.read())
            bmd = ' '.join(lines.replace('\r\n', ' ').replace('\n', ' ').split())

        _cls.values['convertToMeters'] = convertToMeters

        originalConvertToMeters = float(bmd.split('convertToMeters')[-1].split(';')[0])

        conversion = convertToMeters / originalConvertToMeters

        # find vertices
        vertices = list(eval(','.join(bmd.split('vertices')[-1]
                                      .split(';')[0]
                                      .strip()[1:-1]
                                      .split())))

        _cls.__vertices = list(tuple(i / conversion for i in v)
                               for v in vertices)

        # get blocks, order of vertices, nDivXYZ, grading
        blocks = bmd.split('blocks')[-1].split(';')[0].strip()
        xyz, simpleGrading = blocks.split('simpleGrading')

        _cls.__order, _cls.nDivXYZ = eval(','.join(xyz.split('hex')[-1].split()))

        simpleGrading = eval(','.join(simpleGrading.strip()[:-1]
                                      .replace('( ', '(')
                                      .replace(' )', ')')
                                      .split()))

        _cls.grading = SimpleGrading(
            *(MultiGrading(tuple(Grading(*i) for i in g))
              if isinstance(g, tuple) else Grading(g)
              for g in simpleGrading))

        # recreate boundary faces
        boundaryString = bmd.replace(' (', '(').replace(' )', ')') \
            .split('boundary(')[-1].strip().replace('});', '}') \
            .replace('));', ');').replace('((', ' (').replace(')(', ') (')

        _cls.values['boundary'] = {}
        for key, values in CppDictParser(boundaryString).values.iteritems():
            if isinstance(values, dict) and 'type' in values and 'faces' in values:
                values['faces'] = eval(str(values['faces']).replace(' ', ','))

                _cls.values['boundary'][key] = values

        del((lines, bmd))
        return _cls

    @classmethod
    def fromOriginAndSize(cls, origin, width, length, height, convertToMeters=1,
                          nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            origin: Minimum point of bounding box as (x, y, z).
            width: Width in x direction.
            length: Length in y direction.
            height: Height in y direction.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        vertices = [
            vectormath.move(origin,
                            vectormath.sums((vectormath.scale(_xAxis, i * width),
                                             vectormath.scale(_yAxis, j * length),
                                             vectormath.scale(_zAxis, k * height))
                                            ))
            for i in range(2) for j in range(2) for k in range(2)]

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromMinMax(cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None,
                   xAxis=None):
        """Create BlockMeshDict from minimum and maximum point.

        Args:
            minPt: Minimum point of bounding box as (x, y, z).
            maxPt: Maximum point of bounding box as (x, y, z).
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
        diagonal2D = tuple(i - j for i, j in zip(maxPt, minPt))[:2]
        _angle = radians(vectormath.angleAnitclockwise(_xAxis[:2], diagonal2D))
        width = cos(_angle) * vectormath.length(diagonal2D)
        length = sin(_angle) * vectormath.length(diagonal2D)
        height = maxPt[2] - minPt[2]

        vertices = [
            vectormath.move(minPt,
                            vectormath.sums((vectormath.scale(_xAxis, i * width),
                                             vectormath.scale(_yAxis, j * length),
                                             vectormath.scale(_zAxis, k * height))
                                            ))

            for i in range(2) for j in range(2) for k in range(2)]

        return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                                xAxis)

    @classmethod
    def fromVertices(cls, vertices, convertToMeters=1, nDivXYZ=None,
                     grading=None, xAxis=None):
        """Create BlockMeshDict from vertices.

        Args:
            vertices: 8 vertices to define the bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__rawvertices = vertices

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)

        _cls.__vertices = _cls.__sortVertices()

        _cls.__order = tuple(range(8))

        # update self.values['boundary']
        _cls.__updateBoundaryFromSortedVertices()

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading
        _cls.__isFromVertices = True
        return _cls

    @classmethod
    def fromBFBlockGeometries(cls, BFBlockGeometries, convertToMeters=1,
                              nDivXYZ=None, grading=None, xAxis=None):
        """Create BlockMeshDict from BFBlockGeometries.

        Args:
            BFBlockGeometries: A collection of boundary surfaces for bounding box.
            convertToMeters: Scaling factor for the vertex coordinates.
            nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
            grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
            xAxis: An optional tuple that indicates the xAxis direction
                (default: (1, 0)).
        """
        _cls = cls()
        _cls.values['convertToMeters'] = convertToMeters
        _cls.__BFBlockGeometries = BFBlockGeometries

        try:
            # collect uniqe vertices from all BFGeometries
            _cls.__rawvertices = tuple(
                set(v for f in _cls.__BFBlockGeometries
                    for vgroup in f.borderVertices
                    for v in vgroup))
        except AttributeError as e:
            raise TypeError('At least one of the input geometries is not a '
                            'Butterfly block geometry:\n\t{}'.format(e))

        # sort vertices
        _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
        _cls.__vertices = _cls.__sortVertices()

        # update self.values['boundary']
        _cls.__updateBoundaryFromBFBlockGeometries()

        _cls.__order = tuple(range(8))

        _cls.nDivXYZ = nDivXYZ

        # assign grading
        _cls.grading = grading

        return _cls

    @property
    def convertToMeters(self):
        """Get convertToMeters."""
        return self.values['convertToMeters']

    @property
    def boundary(self):
        """Get boundaries and a dictionary."""
        return self.values['boundary']

    @property
    def is2dInXDirection(self):
        """Return True if the case is 2d in X direction."""
        return self.__is2dInXDir

    @property
    def is2dInYDirection(self):
        """Return True if the case is 2d in Y direction."""
        return self.__is2dInYDir

    @property
    def is2dInZDirection(self):
        """Return True if the case is 2d in Z direction."""
        return self.__is2dInZDir

    @property
    def vertices(self):
        """Get the sorted list of vertices."""
        return self.__vertices

    def updateVertices(self, vertices, xAxis=None):
        """Update blockMeshDict vertices."""
        self.__rawvertices = vertices

        # sort vertices
        self.xAxis = xAxis[:2] if xAxis else (1, 0)

        self.__vertices = self.__sortVertices()

        self.__order = tuple(range(8))

        # update self.values['boundary']
        self.__updateBoundaryFromSortedVertices()

    @property
    def verticesOrder(self):
        """Get order of vertices in blocks."""
        return self.__order

    @property
    def geometry(self):
        """A tuple of BFGeometries for BoundingBox faces."""
        def __getBFGeometry(name, attr):
            if name == 'boundingbox_empty':
                bc = EmptyBoundaryCondition()
            else:
                bc = BoundingBoxBoundaryCondition()

            ind = attr['faces'] if hasattr(attr['faces'][0], '__iter__') else \
                (attr['faces'],)

            # unique indecies
            uniuqe = tuple(set(i for inx in ind for i in inx))

            renumberedIndx = tuple(tuple(uniuqe.index(i) for i in inx)
                                   for inx in ind)

            return BFGeometry(name, tuple(self.vertices[i] for i in uniuqe),
                              renumberedIndx, boundaryCondition=bc)

        if not self.__BFBlockGeometries:
            self.__BFBlockGeometries = tuple(
                __getBFGeometry(name, attr)
                for name, attr in self.boundary.iteritems())

        return self.__BFBlockGeometries

    @property
    def width(self):
        """Length of block in X direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[1]])

    @property
    def length(self):
        """Length of block in Y direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[3]])

    @property
    def height(self):
        """Length of block in Z direction."""
        return self.__distance(self.vertices[self.verticesOrder[0]],
                               self.vertices[self.verticesOrder[4]])

    @property
    def center(self):
        """Get center of the block."""
        return self.__averageVerices()

    @property
    def minZ(self):
        """Return minimum Z value of vertices in this block."""
        return self.vertices[self.verticesOrder[0]][2]

    @property
    def nDivXYZ(self):
        """Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5)."""
        return self.__nDivXYZ

    @nDivXYZ.setter
    def nDivXYZ(self, dXYZ):
        self.__nDivXYZ = tuple(int(v) for v in dXYZ) if dXYZ else (5, 5, 5)
        if self.__is2dInXDir:
            self.__nDivXYZ = 1, self.__nDivXYZ[1], self.__nDivXYZ[2]
        elif self.__is2dInYDir:
            self.__nDivXYZ = self.__nDivXYZ[0], 1, self.__nDivXYZ[2]
        elif self.__is2dInZDir:
            self.__nDivXYZ = self.__nDivXYZ[0], self.__nDivXYZ[1], 1

    @property
    def grading(self):
        """A simpleGrading (default: simpleGrading(1, 1, 1))."""
        return self.__grading

    @grading.setter
    def grading(self, g):
        self.__grading = g if g else SimpleGrading()

        assert hasattr(self.grading, 'isSimpleGrading'), \
            'grading input ({}) is not a valid simpleGrading.'.format(g)

    def make3d(self):
        """Reload the 3d blockMeshDict if it has been converted to 2d."""
        if not self.__original3dVertices:
            print('This blockMeshDict is already a 3d blockMeshDict.')
            return
        self.__vertices = self.__original3dVertices
        self.__is2dInXDir = False
        self.__is2dInYDir = False
        self.__is2dInZDir = False

    def make2d(self, planeOrigin, planeNormal, width=0.1):
        """Make the blockMeshDict two dimensional.

        Args:
            planeOrigin: Plane origin as (x, y, z).
            planeNormal: Plane normal as (x, y, z).
            width: width of 2d blockMeshDict (default: 01).
        """
        # copy original vertices
        if not self.__original3dVertices:
            self.__original3dVertices = self.vertices
        else:
            # load original 3d vertices
            self.make3d()

        n = vectormath.normalize(planeNormal)

        # project all vertices to plane and move them in direction of normal
        # by half of width
        self.__vertices = [
            self.__calculate2dPoints(v, planeOrigin, n, width)
            for v in self.vertices]

        # set boundary condition to empty
        # and number of divisions to 1 in shortest side
        minimum = min(self.width, self.length, self.height)
        if self.width == minimum:
            self.nDivXYZ = (1, self.nDivXYZ[1], self.nDivXYZ[2])
            self.__is2dInXDir = True
            # set both sides to empty
            self.__setBoundaryToEmpty(4)
            self.__setBoundaryToEmpty(5)

        elif self.length == minimum:
            self.nDivXYZ = (self.nDivXYZ[0], 1, self.nDivXYZ[2])
            self.__is2dInYDir = True
            # set inlet and outlet to empty
            self.__setBoundaryToEmpty(0)
            self.__setBoundaryToEmpty(1)

        elif self.height == minimum:
            self.nDivXYZ = (self.nDivXYZ[0], self.nDivXYZ[1], 1)
            self.__is2dInZDir = True
            # set top and bottom to empty
            self.__setBoundaryToEmpty(2)
            self.__setBoundaryToEmpty(3)

    def expandUniformByCellsCount(self, count, renumberDivision=True):
        """Expand blockMeshDict boundingbox for n cells from all sides.

        This method will increase the number of divisions by 2 to keep the size
        of the cells unchanged unless renumberDivision is set to False. Use a
        negative count to shrink the bounding box.
        """
        x, y, z = self.nDivXYZ
        self.expandX((self.width / float(x)) * count)
        self.expandY((self.length / float(y)) * count)
        self.expandZ((self.height / float(z)) * count)
        if renumberDivision:
            self.nDivXYZ = (x + 2 * count, y + 2 * count, z + 2 * count)

    def expandByCellsCount(self, xCount, yCount, zCount, renumberDivision=True):
        """Expand blockMeshDict boundingbox for n cells from all sides.

        This method will increase the number of divisions by 2 to keep the size
        of the cells unchanged unless renumberDivision is set to False. Use a
        negative count to shrink the bounding box.
        """
        x, y, z = self.nDivXYZ
        self.expandX((self.width / float(x)) * xCount)
        self.expandY((self.length / float(y)) * yCount)
        self.expandZ((self.height / float(z)) * zCount)
        if renumberDivision:
            self.nDivXYZ = (x + 2 * xCount, y + 2 * yCount, z + 2 * zCount)

    def expandUniform(self, dist):
        """Expand blockMeshDict boundingbox for dist in all directions."""
        if not dist:
            return
        self.expandX(dist)
        self.expandY(dist)
        self.expandZ(dist)

    def expandX(self, dist):
        """Expand blockMeshDict boundingbox for dist in x and -x directions."""
        _xAxis = (self.xAxis[0], self.xAxis[1], 0) if len(self.xAxis) == 2 \
            else self.xAxis

        for i in (0, 3, 7, 4):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_xAxis, -dist))

        for i in (1, 2, 6, 5):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_xAxis, dist))

    def expandY(self, dist):
        """Expand blockMeshDict boundingbox for dist in y and -y directions."""
        _zAxis = (0, 0, 1)
        _yAxis = vectormath.crossProduct(_zAxis, self.xAxis)
        for i in (0, 1, 5, 4):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_yAxis, -dist))

        for i in (3, 2, 6, 7):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_yAxis, dist))

    def expandZ(self, dist):
        """Expand blockMeshDict boundingbox for dist in z and -z directions."""
        _zAxis = (0, 0, 1)
        for i in (0, 1, 2, 3):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_zAxis, -dist))

        for i in (4, 5, 6, 7):
            self.vertices[i] = vectormath.move(
                self.vertices[i], vectormath.scale(_zAxis, dist))

    @staticmethod
    def __calculate2dPoints(v, o, n, w):
        # project point
        p = vectormath.project(v, o, n)
        # move the projected point backwards for half of the width
        t = vectormath.scale(vectormath.normalize(vectormath.subtract(v, p)),
                             w / 2.0)
        return vectormath.move(p, t)

    def nDivXYZByCellSize(self, cellSizeXYZ):
        """Set number of divisions by cell size."""
        x, y, z = cellSizeXYZ
        self.nDivXYZ = int(round(self.width / x)), int(round(self.length / y)), \
            int(round(self.height / z))

    def updateMeshingParameters(self, meshingParameters):
        """Update meshing parameters for blockMeshDict."""
        if not meshingParameters:
            return

        assert hasattr(meshingParameters, 'isMeshingParameters'), \
            'Expected MeshingParameters not {}'.format(type(meshingParameters))

        if meshingParameters.cellSizeXYZ:
            self.nDivXYZByCellSize(meshingParameters.cellSizeXYZ)

        if meshingParameters.grading:
            self.grading = meshingParameters.grading

    @property
    def bottomFaceIndices(self):
        """Get indecies for bottom face."""
        return (self.verticesOrder[0], self.verticesOrder[3],
                self.verticesOrder[2], self.verticesOrder[1])

    @property
    def topFaceIndices(self):
        """Get indecies for top face."""
        return (self.verticesOrder[4], self.verticesOrder[5],
                self.verticesOrder[6], self.verticesOrder[7])

    @property
    def rightFaceIndices(self):
        """Get indecies for right face."""
        return (self.verticesOrder[1], self.verticesOrder[2],
                self.verticesOrder[6], self.verticesOrder[5])

    @property
    def leftFaceIndices(self):
        """Get indecies for left face."""
        return (self.verticesOrder[3], self.verticesOrder[0],
                self.verticesOrder[4], self.verticesOrder[7])

    @property
    def frontFaceIndices(self):
        """Get indecies for front face."""
        return (self.verticesOrder[0], self.verticesOrder[1],
                self.verticesOrder[5], self.verticesOrder[4])

    @property
    def backFaceIndices(self):
        """Get indecies for back face."""
        return (self.verticesOrder[2], self.verticesOrder[3],
                self.verticesOrder[7], self.verticesOrder[6])

    def getFaceIndices(self, faceIndex):
        """Update boundary to empty for one of the faces.

        Args:
            faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
                5 - left.
        """
        faceIndices = {0: self.frontFaceIndices, 1: self.backFaceIndices,
                       2: self.bottomFaceIndices, 3: self.topFaceIndices,
                       4: self.rightFaceIndices, 5: self.leftFaceIndices}

        return faceIndices[faceIndex]

    @property
    def bottomFaceVertices(self):
        """Get vertices for bottom face."""
        return tuple(self.vertices[o] for o in self.bottomFaceIndices)

    @property
    def topFaceVertices(self):
        """Get vertices for top face."""
        return tuple(self.vertices[o] for o in self.topFaceIndices)

    @property
    def rightFaceVertices(self):
        """Get vertices for right face."""
        return tuple(self.vertices[o] for o in self.rightFaceIndices)

    @property
    def leftFaceVertices(self):
        """Get vertices for left face."""
        return tuple(self.vertices[o] for o in self.leftFaceIndices)

    @property
    def frontFaceVertices(self):
        """Get vertices for front face."""
        return tuple(self.vertices[o] for o in self.frontFaceIndices)

    @property
    def backFaceVertices(self):
        """Get vertices for back face."""
        return tuple(self.vertices[o] for o in self.backFaceIndices)

    def getFaceVertices(self, faceIndex):
        """Update boundary to empty for one of the faces.

        Args:
            faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
                5 - left.
        """
        faceVertices = {0: self.frontFaceVertices, 1: self.backFaceVertices,
                        2: self.bottomFaceVertices, 3: self.topFaceVertices,
                        4: self.rightFaceVertices, 5: self.leftFaceVertices}

        return faceVertices[faceIndex]

    def __setBoundaryToEmpty(self, faceIndex):
        """Update boundary to empty for the face based on index.

        Args:
            faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
                5 - left.
        """
        # get indices and vertices for the faceIndex
        ind = self.getFaceIndices(faceIndex)

        if self.__isFromVertices:
            if 'boundingbox_empty' not in self.values['boundary']:
                self.values['boundary']['boundingbox_empty'] = \
                    {'type': 'empty', 'faces': ()}

            self.values['boundary']['boundingbox_empty']['faces'] += (ind,)
            self.values['boundary']['boundingbox']['faces'] = tuple(
                o for o in self.values['boundary']['boundingbox']['faces']
                if o != ind
            )
        else:
            # update boundary condition for the geometry if the boundary is created
            # from geometry
            for name, v in self.values['boundary'].iteritems():
                if ind in v['faces']:
                    v['type'] = 'empty'

                    for geo in self.__BFBlockGeometries:
                        if geo.name == name:
                            geo.boundaryCondition = EmptyBoundaryCondition()
                    break

    def __updateBoundaryFromSortedVertices(self):
        """Update boundary dictionary based ordered vertices."""
        self.values['boundary']['boundingbox'] = {
            'type': 'wall',
            'faces': (self.bottomFaceIndices, self.topFaceIndices,
                      self.rightFaceIndices, self.leftFaceIndices,
                      self.frontFaceIndices, self.backFaceIndices,
                      )
        }

    def __updateBoundaryFromBFBlockGeometries(self):
        """Update boundary dictionary based on BFBlockGeometries input."""
        for geo in self.__BFBlockGeometries:
            try:
                self.values['boundary'][geo.name] = {
                    'type': geo.boundaryCondition.type,
                    'faces': tuple(tuple(self.vertices.index(v) for v in verGroup)
                                   for verGroup in geo.borderVertices)
                }
            except AttributeError as e:
                raise TypeError('Wrong input geometry!\n{}'.format(e))

    def __boundaryToOpenFOAM(self):
        _body = "   %s\n" \
                "   {\n" \
                "       type %s;\n" \
                "       faces\n" \
                "       (" \
                "       %s\n" \
                "       );\n" \
                "   }\n"

        col = (_body % (name, attr['type'],
                        '\n' + '\n'.join('\t' + str(indices).replace(",", "")
                                         for indices in attr['faces']))
               if isinstance(attr['faces'][0], tuple) else
               _body % (name, attr['type'],
                        '\n\t' + str(attr['faces']).replace(",", ""))
               for name, attr in self.boundary.iteritems())

        return 'boundary\n(%s);\n' % '\n'.join(col)

    @staticmethod
    def __distance(v1, v2):
        return sqrt(sum((x - y) ** 2 for x, y in zip(v1, v2)))

    def __averageVerices(self):
        _x, _y, _z = 0, 0, 0

        for ver in self.__rawvertices:
            _x += ver[0]
            _y += ver[1]
            _z += ver[2]

        numofver = len(self.__rawvertices)
        return _x / numofver, _y / numofver, _z / numofver

    def __sortVertices(self):
        """sort input vertices."""
        groups = {}
        for p in self.__rawvertices:
            if p[2] not in groups:
                groups[p[2]] = []

            groups[p[2]].append((p[0], p[1]))

        zValues = groups.keys()
        zValues.sort()
        pointGroups = groups.values()

        assert len(zValues) == 2, \
            'Number of Z values must be 2 not {}: {}.'.format(len(zValues),
                                                              zValues)

        for g in pointGroups:
            assert len(g) == 4

        # the points in both height are identical so I just take the first group
        # and sort them
        xAxisReversed = (-self.xAxis[0], -self.xAxis[1])
        centerPt = self.center[:2]
        sortedPoints2d = \
            sorted(pointGroups[0],
                   key=lambda x: vectormath.angleAnitclockwise(
                       xAxisReversed, tuple(c1 - c2 for c1, c2
                                            in zip(x, centerPt))))

        sortedPoints = [(pt[0], pt[1], z) for z in zValues for pt in sortedPoints2d]
        return sortedPoints

    def toOpenFOAM(self):
        """Return OpenFOAM representation as a string."""
        _hea = self.header()
        _body = "\nconvertToMeters %.4f;\n" \
                "\n" \
                "vertices\n" \
                "(\n\t%s\n);\n" \
                "\n" \
                "blocks\n" \
                "(\nhex %s %s %s\n);\n" \
                "\n" \
                "edges\n" \
                "(%s);\n" \
                "\n" \
                "%s" \
                "\n" \
                "mergePatchPair\n" \
                "(%s);\n"

        return _hea + \
            _body % (
                self.convertToMeters,
                "\n\t".join(tuple(str(ver).replace(",", "")
                                  for ver in self.vertices)),
                str(self.verticesOrder).replace(",", ""),
                str(self.nDivXYZ).replace(",", ""),
                self.grading,  # blocks
                "\n",  # edges
                self.__boundaryToOpenFOAM(),  # boundary
                "\n")  # merge patch pair

    def ToString(self):
        """Overwrite .NET ToString method."""
        return self.__repr__()

    def __repr__(self):
        """BlockMeshDict representation."""
        return self.toOpenFOAM()
</code></pre>
  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#butterfly.blockMeshDict.BlockMeshDict">BlockMeshDict</a></li>
          <li>butterfly.foamfile.FoamFile</li>
          <li>__builtin__.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.convertBoolValue">
    <p>def <span class="ident">convertBoolValue</span>(</p><p>v=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert Boolean values to on/off string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.convertBoolValue', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.convertBoolValue" class="source">
    <pre><code>@staticmethod
def convertBoolValue(v=True):
    """Convert Boolean values to on/off string."""
    _v = ('off', 'on')
    if v in _v:
        return v
    if v:
        return 'on'
    else:
        return 'off'
</code></pre>
  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.backFaceIndices" class="name">var <span class="ident">backFaceIndices</span></p>
            

            
  
    <div class="desc"><p>Get indecies for back face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.backFaceVertices" class="name">var <span class="ident">backFaceVertices</span></p>
            

            
  
    <div class="desc"><p>Get vertices for back face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.bottomFaceIndices" class="name">var <span class="ident">bottomFaceIndices</span></p>
            

            
  
    <div class="desc"><p>Get indecies for bottom face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.bottomFaceVertices" class="name">var <span class="ident">bottomFaceVertices</span></p>
            

            
  
    <div class="desc"><p>Get vertices for bottom face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.boundary" class="name">var <span class="ident">boundary</span></p>
            

            
  
    <div class="desc"><p>Get boundaries and a dictionary.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.center" class="name">var <span class="ident">center</span></p>
            

            
  
    <div class="desc"><p>Get center of the block.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.convertToMeters" class="name">var <span class="ident">convertToMeters</span></p>
            

            
  
    <div class="desc"><p>Get convertToMeters.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.frontFaceIndices" class="name">var <span class="ident">frontFaceIndices</span></p>
            

            
  
    <div class="desc"><p>Get indecies for front face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.frontFaceVertices" class="name">var <span class="ident">frontFaceVertices</span></p>
            

            
  
    <div class="desc"><p>Get vertices for front face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.geometry" class="name">var <span class="ident">geometry</span></p>
            

            
  
    <div class="desc"><p>A tuple of BFGeometries for BoundingBox faces.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.grading" class="name">var <span class="ident">grading</span></p>
            

            
  
    <div class="desc"><p>A simpleGrading (default: simpleGrading(1, 1, 1)).</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.height" class="name">var <span class="ident">height</span></p>
            

            
  
    <div class="desc"><p>Length of block in Z direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.is2dInXDirection" class="name">var <span class="ident">is2dInXDirection</span></p>
            

            
  
    <div class="desc"><p>Return True if the case is 2d in X direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.is2dInYDirection" class="name">var <span class="ident">is2dInYDirection</span></p>
            

            
  
    <div class="desc"><p>Return True if the case is 2d in Y direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.is2dInZDirection" class="name">var <span class="ident">is2dInZDirection</span></p>
            

            
  
    <div class="desc"><p>Return True if the case is 2d in Z direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isConstantFile" class="name">var <span class="ident">isConstantFile</span></p>
            

            
  
    <div class="desc"><p>Check if the file location is 'constant' folder.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isFoamFile" class="name">var <span class="ident">isFoamFile</span></p>
            

            
  
    <div class="desc"><p>Return True for FoamFile.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isSystemFile" class="name">var <span class="ident">isSystemFile</span></p>
            

            
  
    <div class="desc"><p>Check if the file location is 'system' folder.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.isZeroFile" class="name">var <span class="ident">isZeroFile</span></p>
            

            
  
    <div class="desc"><p>Check if the file location is folder 0.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.leftFaceIndices" class="name">var <span class="ident">leftFaceIndices</span></p>
            

            
  
    <div class="desc"><p>Get indecies for left face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.leftFaceVertices" class="name">var <span class="ident">leftFaceVertices</span></p>
            

            
  
    <div class="desc"><p>Get vertices for left face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.length" class="name">var <span class="ident">length</span></p>
            

            
  
    <div class="desc"><p>Length of block in Y direction.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.minZ" class="name">var <span class="ident">minZ</span></p>
            

            
  
    <div class="desc"><p>Return minimum Z value of vertices in this block.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.nDivXYZ" class="name">var <span class="ident">nDivXYZ</span></p>
            

            
  
    <div class="desc"><p>Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.parameters" class="name">var <span class="ident">parameters</span></p>
            

            
  
    <div class="desc"><p>Get list of parameters.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.rightFaceIndices" class="name">var <span class="ident">rightFaceIndices</span></p>
            

            
  
    <div class="desc"><p>Get indecies for right face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.rightFaceVertices" class="name">var <span class="ident">rightFaceVertices</span></p>
            

            
  
    <div class="desc"><p>Get vertices for right face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.topFaceIndices" class="name">var <span class="ident">topFaceIndices</span></p>
            

            
  
    <div class="desc"><p>Get indecies for top face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.topFaceVertices" class="name">var <span class="ident">topFaceVertices</span></p>
            

            
  
    <div class="desc"><p>Get vertices for top face.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.values" class="name">var <span class="ident">values</span></p>
            

            
  
    <div class="desc"><p>Return values as a dictionary.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.vertices" class="name">var <span class="ident">vertices</span></p>
            

            
  
    <div class="desc"><p>Get the sorted list of vertices.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.verticesOrder" class="name">var <span class="ident">verticesOrder</span></p>
            

            
  
    <div class="desc"><p>Get order of vertices in blocks.</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="butterfly.blockMeshDict.BlockMeshDict.width" class="name">var <span class="ident">width</span></p>
            

            
  
    <div class="desc"><p>Length of block in X direction.</p></div>
  <div class="source_cont">
</div>

            </div>
          <h3>Methods</h3>
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, values=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Init class.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.__init__', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.__init__" class="source">
    <pre><code>def __init__(self, values=None):
    """Init class."""
    FoamFile.__init__(self, name='blockMeshDict', cls='dictionary',
                      location='system', defaultValues=self.__defaultValues,
                      values=values)
    self.__BFBlockGeometries = None  # this will be overwritten in classmethods
    self.__vertices = None
    self.__isFromVertices = False
    # variables for 2d blockMeshDict
    self.__is2dInXDir = False
    self.__is2dInYDir = False
    self.__is2dInZDir = False
    self.__original3dVertices = None
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.ToString">
    <p>def <span class="ident">ToString</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Overwrite .NET ToString method.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.ToString', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.ToString" class="source">
    <pre><code>def ToString(self):
    """Overwrite .NET ToString method."""
    return self.__repr__()
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.body">
    <p>def <span class="ident">body</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return body string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.body', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.body" class="source">
    <pre><code>def body(self):
    """Return body string."""
    # remove None values
    def removeNone(d):
        if isinstance(d, (dict, collections.OrderedDict)):
            return collections.OrderedDict(
                (k, removeNone(v)) for k, v in d.iteritems()
                if v == {} or (v and removeNone(v)))
        elif isinstance(d, (list, tuple)):
            return [removeNone(v) for v in d if v and removeNone(v)]
        else:
            return d
        return removeNone
    _values = removeNone(self.values)
    # make python dictionary look like c++ dictionary!!
    of = json.dumps(_values, indent=4, separators=(";", "\t\t")) \
        .replace('\\"', '@').replace('"\n', ";\n").replace('"', '') \
        .replace('};', '}').replace('\t\t{', '{').replace('@', '"')
    # remove first and last {} and prettify[!] the file
    content = (line[4:] if not line.endswith('{') else self._splitLine(line)
               for line in of.split("\n")[1:-1])
    return "\n\n".join(content)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.duplicate">
    <p>def <span class="ident">duplicate</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a copy of this object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.duplicate', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.duplicate" class="source">
    <pre><code>def duplicate(self):
    """Return a copy of this object."""
    return deepcopy(self)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.expandByCellsCount">
    <p>def <span class="ident">expandByCellsCount</span>(</p><p>self, xCount, yCount, zCount, renumberDivision=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Expand blockMeshDict boundingbox for n cells from all sides.</p>
<p>This method will increase the number of divisions by 2 to keep the size
of the cells unchanged unless renumberDivision is set to False. Use a
negative count to shrink the bounding box.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.expandByCellsCount', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.expandByCellsCount" class="source">
    <pre><code>def expandByCellsCount(self, xCount, yCount, zCount, renumberDivision=True):
    """Expand blockMeshDict boundingbox for n cells from all sides.
    This method will increase the number of divisions by 2 to keep the size
    of the cells unchanged unless renumberDivision is set to False. Use a
    negative count to shrink the bounding box.
    """
    x, y, z = self.nDivXYZ
    self.expandX((self.width / float(x)) * xCount)
    self.expandY((self.length / float(y)) * yCount)
    self.expandZ((self.height / float(z)) * zCount)
    if renumberDivision:
        self.nDivXYZ = (x + 2 * xCount, y + 2 * yCount, z + 2 * zCount)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.expandUniform">
    <p>def <span class="ident">expandUniform</span>(</p><p>self, dist)</p>
    </div>
    

    
  
    <div class="desc"><p>Expand blockMeshDict boundingbox for dist in all directions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.expandUniform', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.expandUniform" class="source">
    <pre><code>def expandUniform(self, dist):
    """Expand blockMeshDict boundingbox for dist in all directions."""
    if not dist:
        return
    self.expandX(dist)
    self.expandY(dist)
    self.expandZ(dist)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.expandUniformByCellsCount">
    <p>def <span class="ident">expandUniformByCellsCount</span>(</p><p>self, count, renumberDivision=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Expand blockMeshDict boundingbox for n cells from all sides.</p>
<p>This method will increase the number of divisions by 2 to keep the size
of the cells unchanged unless renumberDivision is set to False. Use a
negative count to shrink the bounding box.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.expandUniformByCellsCount', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.expandUniformByCellsCount" class="source">
    <pre><code>def expandUniformByCellsCount(self, count, renumberDivision=True):
    """Expand blockMeshDict boundingbox for n cells from all sides.
    This method will increase the number of divisions by 2 to keep the size
    of the cells unchanged unless renumberDivision is set to False. Use a
    negative count to shrink the bounding box.
    """
    x, y, z = self.nDivXYZ
    self.expandX((self.width / float(x)) * count)
    self.expandY((self.length / float(y)) * count)
    self.expandZ((self.height / float(z)) * count)
    if renumberDivision:
        self.nDivXYZ = (x + 2 * count, y + 2 * count, z + 2 * count)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.expandX">
    <p>def <span class="ident">expandX</span>(</p><p>self, dist)</p>
    </div>
    

    
  
    <div class="desc"><p>Expand blockMeshDict boundingbox for dist in x and -x directions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.expandX', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.expandX" class="source">
    <pre><code>def expandX(self, dist):
    """Expand blockMeshDict boundingbox for dist in x and -x directions."""
    _xAxis = (self.xAxis[0], self.xAxis[1], 0) if len(self.xAxis) == 2 \
        else self.xAxis
    for i in (0, 3, 7, 4):
        self.vertices[i] = vectormath.move(
            self.vertices[i], vectormath.scale(_xAxis, -dist))
    for i in (1, 2, 6, 5):
        self.vertices[i] = vectormath.move(
            self.vertices[i], vectormath.scale(_xAxis, dist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.expandY">
    <p>def <span class="ident">expandY</span>(</p><p>self, dist)</p>
    </div>
    

    
  
    <div class="desc"><p>Expand blockMeshDict boundingbox for dist in y and -y directions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.expandY', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.expandY" class="source">
    <pre><code>def expandY(self, dist):
    """Expand blockMeshDict boundingbox for dist in y and -y directions."""
    _zAxis = (0, 0, 1)
    _yAxis = vectormath.crossProduct(_zAxis, self.xAxis)
    for i in (0, 1, 5, 4):
        self.vertices[i] = vectormath.move(
            self.vertices[i], vectormath.scale(_yAxis, -dist))
    for i in (3, 2, 6, 7):
        self.vertices[i] = vectormath.move(
            self.vertices[i], vectormath.scale(_yAxis, dist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.expandZ">
    <p>def <span class="ident">expandZ</span>(</p><p>self, dist)</p>
    </div>
    

    
  
    <div class="desc"><p>Expand blockMeshDict boundingbox for dist in z and -z directions.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.expandZ', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.expandZ" class="source">
    <pre><code>def expandZ(self, dist):
    """Expand blockMeshDict boundingbox for dist in z and -z directions."""
    _zAxis = (0, 0, 1)
    for i in (0, 1, 2, 3):
        self.vertices[i] = vectormath.move(
            self.vertices[i], vectormath.scale(_zAxis, -dist))
    for i in (4, 5, 6, 7):
        self.vertices[i] = vectormath.move(
            self.vertices[i], vectormath.scale(_zAxis, dist))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries">
    <p>def <span class="ident">fromBFBlockGeometries</span>(</p><p>cls, BFBlockGeometries, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from BFBlockGeometries.</p>
<p>Args:
    BFBlockGeometries: A collection of boundary surfaces for bounding box.
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromBFBlockGeometries" class="source">
    <pre><code>@classmethod
def fromBFBlockGeometries(cls, BFBlockGeometries, convertToMeters=1,
                          nDivXYZ=None, grading=None, xAxis=None):
    """Create BlockMeshDict from BFBlockGeometries.
    Args:
        BFBlockGeometries: A collection of boundary surfaces for bounding box.
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _cls = cls()
    _cls.values['convertToMeters'] = convertToMeters
    _cls.__BFBlockGeometries = BFBlockGeometries
    try:
        # collect uniqe vertices from all BFGeometries
        _cls.__rawvertices = tuple(
            set(v for f in _cls.__BFBlockGeometries
                for vgroup in f.borderVertices
                for v in vgroup))
    except AttributeError as e:
        raise TypeError('At least one of the input geometries is not a '
                        'Butterfly block geometry:\n\t{}'.format(e))
    # sort vertices
    _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
    _cls.__vertices = _cls.__sortVertices()
    # update self.values['boundary']
    _cls.__updateBoundaryFromBFBlockGeometries()
    _cls.__order = tuple(range(8))
    _cls.nDivXYZ = nDivXYZ
    # assign grading
    _cls.grading = grading
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromFile">
    <p>def <span class="ident">fromFile</span>(</p><p>cls, filepah, convertToMeters=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Create a blockMeshDict from file.</p>
<p>Args:
    filepah: Full path to blockMeshDict.
    converToMeters: converToMeters for the new document. This values
        will be used to update the vertices to the new units. Default
        is 1 which means blockMeshDict will be converted to meters.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromFile', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromFile" class="source">
    <pre><code>@classmethod
def fromFile(cls, filepah, convertToMeters=1):
    """Create a blockMeshDict from file.
    Args:
        filepah: Full path to blockMeshDict.
        converToMeters: converToMeters for the new document. This values
            will be used to update the vertices to the new units. Default
            is 1 which means blockMeshDict will be converted to meters.
    """
    _cls = cls()
    with open(filepah, 'rb') as bf:
        lines = CppDictParser._removeComments(bf.read())
        bmd = ' '.join(lines.replace('\r\n', ' ').replace('\n', ' ').split())
    _cls.values['convertToMeters'] = convertToMeters
    originalConvertToMeters = float(bmd.split('convertToMeters')[-1].split(';')[0])
    conversion = convertToMeters / originalConvertToMeters
    # find vertices
    vertices = list(eval(','.join(bmd.split('vertices')[-1]
                                  .split(';')[0]
                                  .strip()[1:-1]
                                  .split())))
    _cls.__vertices = list(tuple(i / conversion for i in v)
                           for v in vertices)
    # get blocks, order of vertices, nDivXYZ, grading
    blocks = bmd.split('blocks')[-1].split(';')[0].strip()
    xyz, simpleGrading = blocks.split('simpleGrading')
    _cls.__order, _cls.nDivXYZ = eval(','.join(xyz.split('hex')[-1].split()))
    simpleGrading = eval(','.join(simpleGrading.strip()[:-1]
                                  .replace('( ', '(')
                                  .replace(' )', ')')
                                  .split()))
    _cls.grading = SimpleGrading(
        *(MultiGrading(tuple(Grading(*i) for i in g))
          if isinstance(g, tuple) else Grading(g)
          for g in simpleGrading))
    # recreate boundary faces
    boundaryString = bmd.replace(' (', '(').replace(' )', ')') \
        .split('boundary(')[-1].strip().replace('});', '}') \
        .replace('));', ');').replace('((', ' (').replace(')(', ') (')
    _cls.values['boundary'] = {}
    for key, values in CppDictParser(boundaryString).values.iteritems():
        if isinstance(values, dict) and 'type' in values and 'faces' in values:
            values['faces'] = eval(str(values['faces']).replace(' ', ','))
            _cls.values['boundary'][key] = values
    del((lines, bmd))
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromMinMax">
    <p>def <span class="ident">fromMinMax</span>(</p><p>cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from minimum and maximum point.</p>
<p>Args:
    minPt: Minimum point of bounding box as (x, y, z).
    maxPt: Maximum point of bounding box as (x, y, z).
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromMinMax', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromMinMax" class="source">
    <pre><code>@classmethod
def fromMinMax(cls, minPt, maxPt, convertToMeters=1, nDivXYZ=None, grading=None,
               xAxis=None):
    """Create BlockMeshDict from minimum and maximum point.
    Args:
        minPt: Minimum point of bounding box as (x, y, z).
        maxPt: Maximum point of bounding box as (x, y, z).
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
    _zAxis = (0, 0, 1)
    _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
    diagonal2D = tuple(i - j for i, j in zip(maxPt, minPt))[:2]
    _angle = radians(vectormath.angleAnitclockwise(_xAxis[:2], diagonal2D))
    width = cos(_angle) * vectormath.length(diagonal2D)
    length = sin(_angle) * vectormath.length(diagonal2D)
    height = maxPt[2] - minPt[2]
    vertices = [
        vectormath.move(minPt,
                        vectormath.sums((vectormath.scale(_xAxis, i * width),
                                         vectormath.scale(_yAxis, j * length),
                                         vectormath.scale(_zAxis, k * height))
                                        ))
        for i in range(2) for j in range(2) for k in range(2)]
    return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                            xAxis)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize">
    <p>def <span class="ident">fromOriginAndSize</span>(</p><p>cls, origin, width, length, height, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from BFBlockGeometries.</p>
<p>Args:
    origin: Minimum point of bounding box as (x, y, z).
    width: Width in x direction.
    length: Length in y direction.
    height: Height in y direction.
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromOriginAndSize" class="source">
    <pre><code>@classmethod
def fromOriginAndSize(cls, origin, width, length, height, convertToMeters=1,
                      nDivXYZ=None, grading=None, xAxis=None):
    """Create BlockMeshDict from BFBlockGeometries.
    Args:
        origin: Minimum point of bounding box as (x, y, z).
        width: Width in x direction.
        length: Length in y direction.
        height: Height in y direction.
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _xAxis = vectormath.normalize((xAxis[0], xAxis[1], 0) if xAxis else (1, 0, 0))
    _zAxis = (0, 0, 1)
    _yAxis = vectormath.crossProduct(_zAxis, _xAxis)
    vertices = [
        vectormath.move(origin,
                        vectormath.sums((vectormath.scale(_xAxis, i * width),
                                         vectormath.scale(_yAxis, j * length),
                                         vectormath.scale(_zAxis, k * height))
                                        ))
        for i in range(2) for j in range(2) for k in range(2)]
    return cls.fromVertices(vertices, convertToMeters, nDivXYZ, grading,
                            xAxis)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.fromVertices">
    <p>def <span class="ident">fromVertices</span>(</p><p>cls, vertices, convertToMeters=1, nDivXYZ=None, grading=None, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Create BlockMeshDict from vertices.</p>
<p>Args:
    vertices: 8 vertices to define the bounding box.
    convertToMeters: Scaling factor for the vertex coordinates.
    nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
    grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
    xAxis: An optional tuple that indicates the xAxis direction
        (default: (1, 0)).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.fromVertices', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.fromVertices" class="source">
    <pre><code>@classmethod
def fromVertices(cls, vertices, convertToMeters=1, nDivXYZ=None,
                 grading=None, xAxis=None):
    """Create BlockMeshDict from vertices.
    Args:
        vertices: 8 vertices to define the bounding box.
        convertToMeters: Scaling factor for the vertex coordinates.
        nDivXYZ: Number of divisions in (x, y, z) as a tuple (default: 5, 5, 5).
        grading: A simpleGrading (default: simpleGrading(1, 1, 1)).
        xAxis: An optional tuple that indicates the xAxis direction
            (default: (1, 0)).
    """
    _cls = cls()
    _cls.values['convertToMeters'] = convertToMeters
    _cls.__rawvertices = vertices
    # sort vertices
    _cls.xAxis = xAxis[:2] if xAxis else (1, 0)
    _cls.__vertices = _cls.__sortVertices()
    _cls.__order = tuple(range(8))
    # update self.values['boundary']
    _cls.__updateBoundaryFromSortedVertices()
    _cls.nDivXYZ = nDivXYZ
    # assign grading
    _cls.grading = grading
    _cls.__isFromVertices = True
    return _cls
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.getFaceIndices">
    <p>def <span class="ident">getFaceIndices</span>(</p><p>self, faceIndex)</p>
    </div>
    

    
  
    <div class="desc"><p>Update boundary to empty for one of the faces.</p>
<p>Args:
    faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
        5 - left.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.getFaceIndices', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.getFaceIndices" class="source">
    <pre><code>def getFaceIndices(self, faceIndex):
    """Update boundary to empty for one of the faces.
    Args:
        faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
            5 - left.
    """
    faceIndices = {0: self.frontFaceIndices, 1: self.backFaceIndices,
                   2: self.bottomFaceIndices, 3: self.topFaceIndices,
                   4: self.rightFaceIndices, 5: self.leftFaceIndices}
    return faceIndices[faceIndex]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.getFaceVertices">
    <p>def <span class="ident">getFaceVertices</span>(</p><p>self, faceIndex)</p>
    </div>
    

    
  
    <div class="desc"><p>Update boundary to empty for one of the faces.</p>
<p>Args:
    faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
        5 - left.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.getFaceVertices', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.getFaceVertices" class="source">
    <pre><code>def getFaceVertices(self, faceIndex):
    """Update boundary to empty for one of the faces.
    Args:
        faceIndex: 0 - front, 1 - back, 2 - bottom, 3 - top, 4 - right,
            5 - left.
    """
    faceVertices = {0: self.frontFaceVertices, 1: self.backFaceVertices,
                    2: self.bottomFaceVertices, 3: self.topFaceVertices,
                    4: self.rightFaceVertices, 5: self.leftFaceVertices}
    return faceVertices[faceIndex]
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.getValueByParameter">
    <p>def <span class="ident">getValueByParameter</span>(</p><p>self, parameter)</p>
    </div>
    

    
  
    <div class="desc"><p>Get values for a given parameter by parameter name.</p>
<p>Args:
    parameter: Name of a parameter as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.getValueByParameter', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.getValueByParameter" class="source">
    <pre><code>def getValueByParameter(self, parameter):
    """Get values for a given parameter by parameter name.
    Args:
        parameter: Name of a parameter as a string.
    """
    try:
        return self.values[parameter]
    except KeyError:
        raise KeyError('{} is not available in {}.'.format(
            parameter, self.__class__.__name__
        ))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.header">
    <p>def <span class="ident">header</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return open foam style string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.header', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.header" class="source">
    <pre><code>def header(self):
    """Return open foam style string."""
    if self.location:
        return Header.header() + \
            "FoamFile\n{\n" \
            "\tversion\t\t%s;\n" \
            "\tformat\t\t%s;\n" \
            "\tclass\t\t%s;\n" \
            "\tlocation\t%s;\n" \
            "\tobject\t\t%s;\n" \
            "}\n" % (self.__version, self.format, self.cls, self.location,
                     self.name)
    else:
        return Header.header() + \
            "FoamFile\n{\n" \
            "\tversion\t\t%s;\n" \
            "\tformat\t\t%s;\n" \
            "\tclass\t\t%s;\n" \
            "\tobject\t\t%s;\n" \
            "}\n" % (self.__version, self.format, self.cls, self.name)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.make2d">
    <p>def <span class="ident">make2d</span>(</p><p>self, planeOrigin, planeNormal, width=0.1)</p>
    </div>
    

    
  
    <div class="desc"><p>Make the blockMeshDict two dimensional.</p>
<p>Args:
    planeOrigin: Plane origin as (x, y, z).
    planeNormal: Plane normal as (x, y, z).
    width: width of 2d blockMeshDict (default: 01).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.make2d', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.make2d" class="source">
    <pre><code>def make2d(self, planeOrigin, planeNormal, width=0.1):
    """Make the blockMeshDict two dimensional.
    Args:
        planeOrigin: Plane origin as (x, y, z).
        planeNormal: Plane normal as (x, y, z).
        width: width of 2d blockMeshDict (default: 01).
    """
    # copy original vertices
    if not self.__original3dVertices:
        self.__original3dVertices = self.vertices
    else:
        # load original 3d vertices
        self.make3d()
    n = vectormath.normalize(planeNormal)
    # project all vertices to plane and move them in direction of normal
    # by half of width
    self.__vertices = [
        self.__calculate2dPoints(v, planeOrigin, n, width)
        for v in self.vertices]
    # set boundary condition to empty
    # and number of divisions to 1 in shortest side
    minimum = min(self.width, self.length, self.height)
    if self.width == minimum:
        self.nDivXYZ = (1, self.nDivXYZ[1], self.nDivXYZ[2])
        self.__is2dInXDir = True
        # set both sides to empty
        self.__setBoundaryToEmpty(4)
        self.__setBoundaryToEmpty(5)
    elif self.length == minimum:
        self.nDivXYZ = (self.nDivXYZ[0], 1, self.nDivXYZ[2])
        self.__is2dInYDir = True
        # set inlet and outlet to empty
        self.__setBoundaryToEmpty(0)
        self.__setBoundaryToEmpty(1)
    elif self.height == minimum:
        self.nDivXYZ = (self.nDivXYZ[0], self.nDivXYZ[1], 1)
        self.__is2dInZDir = True
        # set top and bottom to empty
        self.__setBoundaryToEmpty(2)
        self.__setBoundaryToEmpty(3)
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.make3d">
    <p>def <span class="ident">make3d</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Reload the 3d blockMeshDict if it has been converted to 2d.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.make3d', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.make3d" class="source">
    <pre><code>def make3d(self):
    """Reload the 3d blockMeshDict if it has been converted to 2d."""
    if not self.__original3dVertices:
        print('This blockMeshDict is already a 3d blockMeshDict.')
        return
    self.__vertices = self.__original3dVertices
    self.__is2dInXDir = False
    self.__is2dInYDir = False
    self.__is2dInZDir = False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize">
    <p>def <span class="ident">nDivXYZByCellSize</span>(</p><p>self, cellSizeXYZ)</p>
    </div>
    

    
  
    <div class="desc"><p>Set number of divisions by cell size.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.nDivXYZByCellSize" class="source">
    <pre><code>def nDivXYZByCellSize(self, cellSizeXYZ):
    """Set number of divisions by cell size."""
    x, y, z = cellSizeXYZ
    self.nDivXYZ = int(round(self.width / x)), int(round(self.length / y)), \
        int(round(self.height / z))
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.save">
    <p>def <span class="ident">save</span>(</p><p>self, projectFolder, subFolder=None, overwrite=True)</p>
    </div>
    

    
  
    <div class="desc"><p>Save to file.</p>
<p>Args:
    projectFolder: Path to project folder as a string.
    subFolder: Optional input for subFolder (default: self.location).</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.save', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.save" class="source">
    <pre><code>def save(self, projectFolder, subFolder=None, overwrite=True):
    """Save to file.
    Args:
        projectFolder: Path to project folder as a string.
        subFolder: Optional input for subFolder (default: self.location).
    """
    subFolder = subFolder or self.location.replace('"', '')
    fp = os.path.join(projectFolder, subFolder, self.name)
    if not overwrite and os.path.isfile(fp):
        return
    with open(fp, "wb") as outf:
        outf.write(self.toOpenFOAM())
    return fp
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.setValueByParameter">
    <p>def <span class="ident">setValueByParameter</span>(</p><p>self, parameter, value)</p>
    </div>
    

    
  
    <div class="desc"><p>Set value for a parameter.</p>
<p>Args:
    parameter: Name of a parameter as a string.
    value: Parameter value as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.setValueByParameter', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.setValueByParameter" class="source">
    <pre><code>def setValueByParameter(self, parameter, value):
    """Set value for a parameter.
    Args:
        parameter: Name of a parameter as a string.
        value: Parameter value as a string.
    """
    self.values[parameter] = value
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM">
    <p>def <span class="ident">toOpenFOAM</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return OpenFOAM representation as a string.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.toOpenFOAM" class="source">
    <pre><code>def toOpenFOAM(self):
    """Return OpenFOAM representation as a string."""
    _hea = self.header()
    _body = "\nconvertToMeters %.4f;\n" \
            "\n" \
            "vertices\n" \
            "(\n\t%s\n);\n" \
            "\n" \
            "blocks\n" \
            "(\nhex %s %s %s\n);\n" \
            "\n" \
            "edges\n" \
            "(%s);\n" \
            "\n" \
            "%s" \
            "\n" \
            "mergePatchPair\n" \
            "(%s);\n"
    return _hea + \
        _body % (
            self.convertToMeters,
            "\n\t".join(tuple(str(ver).replace(",", "")
                              for ver in self.vertices)),
            str(self.verticesOrder).replace(",", ""),
            str(self.nDivXYZ).replace(",", ""),
            self.grading,  # blocks
            "\n",  # edges
            self.__boundaryToOpenFOAM(),  # boundary
            "\n")  # merge patch pair
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters">
    <p>def <span class="ident">updateMeshingParameters</span>(</p><p>self, meshingParameters)</p>
    </div>
    

    
  
    <div class="desc"><p>Update meshing parameters for blockMeshDict.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.updateMeshingParameters" class="source">
    <pre><code>def updateMeshingParameters(self, meshingParameters):
    """Update meshing parameters for blockMeshDict."""
    if not meshingParameters:
        return
    assert hasattr(meshingParameters, 'isMeshingParameters'), \
        'Expected MeshingParameters not {}'.format(type(meshingParameters))
    if meshingParameters.cellSizeXYZ:
        self.nDivXYZByCellSize(meshingParameters.cellSizeXYZ)
    if meshingParameters.grading:
        self.grading = meshingParameters.grading
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.updateValues">
    <p>def <span class="ident">updateValues</span>(</p><p>self, v, replace=False, mute=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Update current values from dictionary v.</p>
<p>if key is not available in current values it will be added, if the key
already exists it will be updated.</p>
<p>Returns:
    True is the dictionary is updated.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.updateValues', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.updateValues" class="source">
    <pre><code>def updateValues(self, v, replace=False, mute=False):
    """Update current values from dictionary v.
    if key is not available in current values it will be added, if the key
    already exists it will be updated.
    Returns:
        True is the dictionary is updated.
    """
    def logChanges(original, new):
        """compare this dictionary with the current values."""
        if original is None:
            original = {}
        for key, value in new.items():
            if key not in original:
                # there is a new key so dictionary has changed.
                if not mute:
                    msg = '{} :: New values are added for {}.' \
                        .format('.'.join(self.__parents), key)
                    print(msg)
                self.__hasChanged = True
                return
            if isinstance(value, (dict, collections.OrderedDict)):
                self.__parents.append(key)
                logChanges(original[key], value)
            elif str(original[key]) != str(value):
                    # there is a change in value
                    if not mute:
                        msg = '{}.{} is changed from "{}" to "{}".'\
                            .format('.'.join(self.__parents), key,
                                    original[key] if len(str(original[key])) < 100
                                    else '%s...' % str(original[key])[:100],
                                    value if len(str(value)) < 100
                                    else '%s...' % str(value)[:100])
                        print(msg)
                    self.__hasChanged = True
                    return
    def modifyDict(original, new):
        """Modify a dictionary based on a new dictionary."""
        for key, value in new.items():
            if key in original and isinstance(value, dict):
                if isinstance(original[key], dict):
                    modifyDict(original[key], value)
                else:
                    # the value was not a dict, replce them with the new one
                    original[key] = value
            else:
                original[key] = value
        return original
    assert isinstance(v, dict), 'Expected dictionary not {}!'.format(type(v))
    self.__parents = [self.__class__.__name__]
    self.__hasChanged = False
    logChanges(self.__values, v)
    if self.__hasChanged:
        if replace:
            self.__values.update(v)
        else:
            self.__values = modifyDict(self.__values, v)
        return True
    else:
        return False
</code></pre>
  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="butterfly.blockMeshDict.BlockMeshDict.updateVertices">
    <p>def <span class="ident">updateVertices</span>(</p><p>self, vertices, xAxis=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Update blockMeshDict vertices.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-butterfly.blockMeshDict.BlockMeshDict.updateVertices', this);">Show source &equiv;</a></p>
  <div id="source-butterfly.blockMeshDict.BlockMeshDict.updateVertices" class="source">
    <pre><code>def updateVertices(self, vertices, xAxis=None):
    """Update blockMeshDict vertices."""
    self.__rawvertices = vertices
    # sort vertices
    self.xAxis = xAxis[:2] if xAxis else (1, 0)
    self.__vertices = self.__sortVertices()
    self.__order = tuple(range(8))
    # update self.values['boundary']
    self.__updateBoundaryFromSortedVertices()
</code></pre>
  </div>
</div>

  </div>
  
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a>
    </p>
  </footer>
</div>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
